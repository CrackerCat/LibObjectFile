//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace LibObjectFile.Elf
{
    using System.Runtime.InteropServices;
    
    internal static partial class RawElf
    {
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Elf32_Ehdr
        {
            /// <summary>
            /// Magic number and other info
            /// </summary>
            public fixed byte e_ident[16];
            
            /// <summary>
            /// Object file type
            /// </summary>
            public RawElf.Elf32_Half e_type;
            
            /// <summary>
            /// Architecture
            /// </summary>
            public RawElf.Elf32_Half e_machine;
            
            /// <summary>
            /// Object file version
            /// </summary>
            public RawElf.Elf32_Word e_version;
            
            /// <summary>
            /// Entry point virtual address
            /// </summary>
            public RawElf.Elf32_Addr e_entry;
            
            /// <summary>
            /// Program header table file offset
            /// </summary>
            public RawElf.Elf32_Off e_phoff;
            
            /// <summary>
            /// Section header table file offset
            /// </summary>
            public RawElf.Elf32_Off e_shoff;
            
            /// <summary>
            /// Processor-specific flags
            /// </summary>
            public RawElf.Elf32_Word e_flags;
            
            /// <summary>
            /// ELF header size in bytes
            /// </summary>
            public RawElf.Elf32_Half e_ehsize;
            
            /// <summary>
            /// Program header table entry size
            /// </summary>
            public RawElf.Elf32_Half e_phentsize;
            
            /// <summary>
            /// Program header table entry count
            /// </summary>
            public RawElf.Elf32_Half e_phnum;
            
            /// <summary>
            /// Section header table entry size
            /// </summary>
            public RawElf.Elf32_Half e_shentsize;
            
            /// <summary>
            /// Section header table entry count
            /// </summary>
            public RawElf.Elf32_Half e_shnum;
            
            /// <summary>
            /// Section header string table index
            /// </summary>
            public RawElf.Elf32_Half e_shstrndx;
        }
        
        /// <summary>
        /// Type for a 16-bit quantity.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Half : IEquatable<Elf32_Half>
        {
            public Elf32_Half(ushort value) => this.Value = value;
            
            public readonly ushort Value;
            
            public bool Equals(Elf32_Half other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Half other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ushort(Elf32_Half from) => from.Value;
            
            public static implicit operator Elf32_Half(ushort from) => new Elf32_Half(from);
            
            public static bool operator ==(Elf32_Half left, Elf32_Half right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Half left, Elf32_Half right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Types for signed and unsigned 32-bit quantities.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Word : IEquatable<Elf32_Word>
        {
            public Elf32_Word(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(Elf32_Word other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Word other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(Elf32_Word from) => from.Value;
            
            public static implicit operator Elf32_Word(uint from) => new Elf32_Word(from);
            
            public static bool operator ==(Elf32_Word left, Elf32_Word right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Word left, Elf32_Word right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Type of addresses.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Addr : IEquatable<Elf32_Addr>
        {
            public Elf32_Addr(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(Elf32_Addr other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Addr other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(Elf32_Addr from) => from.Value;
            
            public static implicit operator Elf32_Addr(uint from) => new Elf32_Addr(from);
            
            public static bool operator ==(Elf32_Addr left, Elf32_Addr right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Addr left, Elf32_Addr right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Type of file offsets.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Off : IEquatable<Elf32_Off>
        {
            public Elf32_Off(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(Elf32_Off other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Off other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(Elf32_Off from) => from.Value;
            
            public static implicit operator Elf32_Off(uint from) => new Elf32_Off(from);
            
            public static bool operator ==(Elf32_Off left, Elf32_Off right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Off left, Elf32_Off right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Elf64_Ehdr
        {
            /// <summary>
            /// Magic number and other info
            /// </summary>
            public fixed byte e_ident[16];
            
            /// <summary>
            /// Object file type
            /// </summary>
            public RawElf.Elf64_Half e_type;
            
            /// <summary>
            /// Architecture
            /// </summary>
            public RawElf.Elf64_Half e_machine;
            
            /// <summary>
            /// Object file version
            /// </summary>
            public RawElf.Elf64_Word e_version;
            
            /// <summary>
            /// Entry point virtual address
            /// </summary>
            public RawElf.Elf64_Addr e_entry;
            
            /// <summary>
            /// Program header table file offset
            /// </summary>
            public RawElf.Elf64_Off e_phoff;
            
            /// <summary>
            /// Section header table file offset
            /// </summary>
            public RawElf.Elf64_Off e_shoff;
            
            /// <summary>
            /// Processor-specific flags
            /// </summary>
            public RawElf.Elf64_Word e_flags;
            
            /// <summary>
            /// ELF header size in bytes
            /// </summary>
            public RawElf.Elf64_Half e_ehsize;
            
            /// <summary>
            /// Program header table entry size
            /// </summary>
            public RawElf.Elf64_Half e_phentsize;
            
            /// <summary>
            /// Program header table entry count
            /// </summary>
            public RawElf.Elf64_Half e_phnum;
            
            /// <summary>
            /// Section header table entry size
            /// </summary>
            public RawElf.Elf64_Half e_shentsize;
            
            /// <summary>
            /// Section header table entry count
            /// </summary>
            public RawElf.Elf64_Half e_shnum;
            
            /// <summary>
            /// Section header string table index
            /// </summary>
            public RawElf.Elf64_Half e_shstrndx;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Half : IEquatable<Elf64_Half>
        {
            public Elf64_Half(ushort value) => this.Value = value;
            
            public readonly ushort Value;
            
            public bool Equals(Elf64_Half other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Half other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ushort(Elf64_Half from) => from.Value;
            
            public static implicit operator Elf64_Half(ushort from) => new Elf64_Half(from);
            
            public static bool operator ==(Elf64_Half left, Elf64_Half right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Half left, Elf64_Half right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Word : IEquatable<Elf64_Word>
        {
            public Elf64_Word(uint value) => this.Value = value;
            
            public readonly uint Value;
            
            public bool Equals(Elf64_Word other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Word other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator uint(Elf64_Word from) => from.Value;
            
            public static implicit operator Elf64_Word(uint from) => new Elf64_Word(from);
            
            public static bool operator ==(Elf64_Word left, Elf64_Word right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Word left, Elf64_Word right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Addr : IEquatable<Elf64_Addr>
        {
            public Elf64_Addr(ulong value) => this.Value = value;
            
            public readonly ulong Value;
            
            public bool Equals(Elf64_Addr other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Addr other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(Elf64_Addr from) => from.Value;
            
            public static implicit operator Elf64_Addr(ulong from) => new Elf64_Addr(from);
            
            public static bool operator ==(Elf64_Addr left, Elf64_Addr right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Addr left, Elf64_Addr right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Off : IEquatable<Elf64_Off>
        {
            public Elf64_Off(ulong value) => this.Value = value;
            
            public readonly ulong Value;
            
            public bool Equals(Elf64_Off other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Off other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(Elf64_Off from) => from.Value;
            
            public static implicit operator Elf64_Off(ulong from) => new Elf64_Off(from);
            
            public static bool operator ==(Elf64_Off left, Elf64_Off right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Off left, Elf64_Off right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Section header.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Shdr
        {
            /// <summary>
            /// Section name (string tbl index)
            /// </summary>
            public RawElf.Elf32_Word sh_name;
            
            /// <summary>
            /// Section type
            /// </summary>
            public RawElf.Elf32_Word sh_type;
            
            /// <summary>
            /// Section flags
            /// </summary>
            public RawElf.Elf32_Word sh_flags;
            
            /// <summary>
            /// Section virtual addr at execution
            /// </summary>
            public RawElf.Elf32_Addr sh_addr;
            
            /// <summary>
            /// Section file offset
            /// </summary>
            public RawElf.Elf32_Off sh_offset;
            
            /// <summary>
            /// Section size in bytes
            /// </summary>
            public RawElf.Elf32_Word sh_size;
            
            /// <summary>
            /// Link to another section
            /// </summary>
            public RawElf.Elf32_Word sh_link;
            
            /// <summary>
            /// Additional section information
            /// </summary>
            public RawElf.Elf32_Word sh_info;
            
            /// <summary>
            /// Section alignment
            /// </summary>
            public RawElf.Elf32_Word sh_addralign;
            
            /// <summary>
            /// Entry size if section holds table
            /// </summary>
            public RawElf.Elf32_Word sh_entsize;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Shdr
        {
            /// <summary>
            /// Section name (string tbl index)
            /// </summary>
            public RawElf.Elf64_Word sh_name;
            
            /// <summary>
            /// Section type
            /// </summary>
            public RawElf.Elf64_Word sh_type;
            
            /// <summary>
            /// Section flags
            /// </summary>
            public RawElf.Elf64_Xword sh_flags;
            
            /// <summary>
            /// Section virtual addr at execution
            /// </summary>
            public RawElf.Elf64_Addr sh_addr;
            
            /// <summary>
            /// Section file offset
            /// </summary>
            public RawElf.Elf64_Off sh_offset;
            
            /// <summary>
            /// Section size in bytes
            /// </summary>
            public RawElf.Elf64_Xword sh_size;
            
            /// <summary>
            /// Link to another section
            /// </summary>
            public RawElf.Elf64_Word sh_link;
            
            /// <summary>
            /// Additional section information
            /// </summary>
            public RawElf.Elf64_Word sh_info;
            
            /// <summary>
            /// Section alignment
            /// </summary>
            public RawElf.Elf64_Xword sh_addralign;
            
            /// <summary>
            /// Entry size if section holds table
            /// </summary>
            public RawElf.Elf64_Xword sh_entsize;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Xword : IEquatable<Elf64_Xword>
        {
            public Elf64_Xword(ulong value) => this.Value = value;
            
            public readonly ulong Value;
            
            public bool Equals(Elf64_Xword other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Xword other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(Elf64_Xword from) => from.Value;
            
            public static implicit operator Elf64_Xword(ulong from) => new Elf64_Xword(from);
            
            public static bool operator ==(Elf64_Xword left, Elf64_Xword right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Xword left, Elf64_Xword right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Section compression header.  Used when SHF_COMPRESSED is set.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Chdr
        {
            /// <summary>
            /// Compression format.
            /// </summary>
            public RawElf.Elf32_Word ch_type;
            
            /// <summary>
            /// Uncompressed data size.
            /// </summary>
            public RawElf.Elf32_Word ch_size;
            
            /// <summary>
            /// Uncompressed data alignment.
            /// </summary>
            public RawElf.Elf32_Word ch_addralign;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Chdr
        {
            /// <summary>
            /// Compression format.
            /// </summary>
            public RawElf.Elf64_Word ch_type;
            
            public RawElf.Elf64_Word ch_reserved;
            
            /// <summary>
            /// Uncompressed data size.
            /// </summary>
            public RawElf.Elf64_Xword ch_size;
            
            /// <summary>
            /// Uncompressed data alignment.
            /// </summary>
            public RawElf.Elf64_Xword ch_addralign;
        }
        
        /// <summary>
        /// Symbol table entry.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Sym
        {
            /// <summary>
            /// Symbol name (string tbl index)
            /// </summary>
            public RawElf.Elf32_Word st_name;
            
            /// <summary>
            /// Symbol value
            /// </summary>
            public RawElf.Elf32_Addr st_value;
            
            /// <summary>
            /// Symbol size
            /// </summary>
            public RawElf.Elf32_Word st_size;
            
            /// <summary>
            /// Symbol type and binding
            /// </summary>
            public byte st_info;
            
            /// <summary>
            /// Symbol visibility
            /// </summary>
            public byte st_other;
            
            /// <summary>
            /// Section index
            /// </summary>
            public RawElf.Elf32_Section st_shndx;
        }
        
        /// <summary>
        /// Type for section indices, which are 16-bit quantities.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Section : IEquatable<Elf32_Section>
        {
            public Elf32_Section(ushort value) => this.Value = value;
            
            public readonly ushort Value;
            
            public bool Equals(Elf32_Section other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Section other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ushort(Elf32_Section from) => from.Value;
            
            public static implicit operator Elf32_Section(ushort from) => new Elf32_Section(from);
            
            public static bool operator ==(Elf32_Section left, Elf32_Section right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Section left, Elf32_Section right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Sym
        {
            /// <summary>
            /// Symbol name (string tbl index)
            /// </summary>
            public RawElf.Elf64_Word st_name;
            
            /// <summary>
            /// Symbol type and binding
            /// </summary>
            public byte st_info;
            
            /// <summary>
            /// Symbol visibility
            /// </summary>
            public byte st_other;
            
            /// <summary>
            /// Section index
            /// </summary>
            public RawElf.Elf64_Section st_shndx;
            
            /// <summary>
            /// Symbol value
            /// </summary>
            public RawElf.Elf64_Addr st_value;
            
            /// <summary>
            /// Symbol size
            /// </summary>
            public RawElf.Elf64_Xword st_size;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Section : IEquatable<Elf64_Section>
        {
            public Elf64_Section(ushort value) => this.Value = value;
            
            public readonly ushort Value;
            
            public bool Equals(Elf64_Section other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Section other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ushort(Elf64_Section from) => from.Value;
            
            public static implicit operator Elf64_Section(ushort from) => new Elf64_Section(from);
            
            public static bool operator ==(Elf64_Section left, Elf64_Section right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Section left, Elf64_Section right) => !left.Equals(right);
        }
        
        /// <summary>
        /// The syminfo section if available contains additional information about
        /// every dynamic symbol.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Syminfo
        {
            /// <summary>
            /// Direct bindings, symbol bound to
            /// </summary>
            public RawElf.Elf32_Half si_boundto;
            
            /// <summary>
            /// Per symbol flags
            /// </summary>
            public RawElf.Elf32_Half si_flags;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Syminfo
        {
            /// <summary>
            /// Direct bindings, symbol bound to
            /// </summary>
            public RawElf.Elf64_Half si_boundto;
            
            /// <summary>
            /// Per symbol flags
            /// </summary>
            public RawElf.Elf64_Half si_flags;
        }
        
        /// <summary>
        /// Relocation table entry without addend (in section of type SHT_REL).
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Rel
        {
            /// <summary>
            /// Address
            /// </summary>
            public RawElf.Elf32_Addr r_offset;
            
            /// <summary>
            /// Relocation type and symbol index
            /// </summary>
            public RawElf.Elf32_Word r_info;
        }
        
        /// <summary>
        /// I have seen two different definitions of the Elf64_Rel and
        /// Elf64_Rela structures, so we'll leave them out until Novell (or
        /// whoever) gets their act together.
        /// </summary>
        /// <remarks>
        /// The following, at least, is used on Sparc v9, MIPS, and Alpha.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Rel
        {
            /// <summary>
            /// Address
            /// </summary>
            public RawElf.Elf64_Addr r_offset;
            
            /// <summary>
            /// Relocation type and symbol index
            /// </summary>
            public RawElf.Elf64_Xword r_info;
        }
        
        /// <summary>
        /// Relocation table entry with addend (in section of type SHT_RELA).
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Rela
        {
            /// <summary>
            /// Address
            /// </summary>
            public RawElf.Elf32_Addr r_offset;
            
            /// <summary>
            /// Relocation type and symbol index
            /// </summary>
            public RawElf.Elf32_Word r_info;
            
            /// <summary>
            /// Addend
            /// </summary>
            public RawElf.Elf32_Sword r_addend;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Sword : IEquatable<Elf32_Sword>
        {
            public Elf32_Sword(int value) => this.Value = value;
            
            public readonly int Value;
            
            public bool Equals(Elf32_Sword other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Sword other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator int(Elf32_Sword from) => from.Value;
            
            public static implicit operator Elf32_Sword(int from) => new Elf32_Sword(from);
            
            public static bool operator ==(Elf32_Sword left, Elf32_Sword right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Sword left, Elf32_Sword right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Rela
        {
            /// <summary>
            /// Address
            /// </summary>
            public RawElf.Elf64_Addr r_offset;
            
            /// <summary>
            /// Relocation type and symbol index
            /// </summary>
            public RawElf.Elf64_Xword r_info;
            
            /// <summary>
            /// Addend
            /// </summary>
            public RawElf.Elf64_Sxword r_addend;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Sxword : IEquatable<Elf64_Sxword>
        {
            public Elf64_Sxword(long value) => this.Value = value;
            
            public readonly long Value;
            
            public bool Equals(Elf64_Sxword other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Sxword other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator long(Elf64_Sxword from) => from.Value;
            
            public static implicit operator Elf64_Sxword(long from) => new Elf64_Sxword(from);
            
            public static bool operator ==(Elf64_Sxword left, Elf64_Sxword right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Sxword left, Elf64_Sxword right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Program segment header.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Phdr
        {
            /// <summary>
            /// Segment type
            /// </summary>
            public RawElf.Elf32_Word p_type;
            
            /// <summary>
            /// Segment file offset
            /// </summary>
            public RawElf.Elf32_Off p_offset;
            
            /// <summary>
            /// Segment virtual address
            /// </summary>
            public RawElf.Elf32_Addr p_vaddr;
            
            /// <summary>
            /// Segment physical address
            /// </summary>
            public RawElf.Elf32_Addr p_paddr;
            
            /// <summary>
            /// Segment size in file
            /// </summary>
            public RawElf.Elf32_Word p_filesz;
            
            /// <summary>
            /// Segment size in memory
            /// </summary>
            public RawElf.Elf32_Word p_memsz;
            
            /// <summary>
            /// Segment flags
            /// </summary>
            public RawElf.Elf32_Word p_flags;
            
            /// <summary>
            /// Segment alignment
            /// </summary>
            public RawElf.Elf32_Word p_align;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Phdr
        {
            /// <summary>
            /// Segment type
            /// </summary>
            public RawElf.Elf64_Word p_type;
            
            /// <summary>
            /// Segment flags
            /// </summary>
            public RawElf.Elf64_Word p_flags;
            
            /// <summary>
            /// Segment file offset
            /// </summary>
            public RawElf.Elf64_Off p_offset;
            
            /// <summary>
            /// Segment virtual address
            /// </summary>
            public RawElf.Elf64_Addr p_vaddr;
            
            /// <summary>
            /// Segment physical address
            /// </summary>
            public RawElf.Elf64_Addr p_paddr;
            
            /// <summary>
            /// Segment size in file
            /// </summary>
            public RawElf.Elf64_Xword p_filesz;
            
            /// <summary>
            /// Segment size in memory
            /// </summary>
            public RawElf.Elf64_Xword p_memsz;
            
            /// <summary>
            /// Segment alignment
            /// </summary>
            public RawElf.Elf64_Xword p_align;
        }
        
        /// <summary>
        /// Dynamic section entry.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Dyn
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct Elf32_Dyn_union_d_un
            {
                /// <summary>
                /// Integer value
                /// </summary>
                [FieldOffset(0)]
                public RawElf.Elf32_Word d_val;
                
                /// <summary>
                /// Address value
                /// </summary>
                [FieldOffset(0)]
                public RawElf.Elf32_Addr d_ptr;
            }
            
            /// <summary>
            /// Dynamic entry type
            /// </summary>
            public RawElf.Elf32_Sword d_tag;
            
            public RawElf.Elf32_Dyn.Elf32_Dyn_union_d_un d_un;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Dyn
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct Elf64_Dyn_union_d_un
            {
                /// <summary>
                /// Integer value
                /// </summary>
                [FieldOffset(0)]
                public RawElf.Elf64_Xword d_val;
                
                /// <summary>
                /// Address value
                /// </summary>
                [FieldOffset(0)]
                public RawElf.Elf64_Addr d_ptr;
            }
            
            /// <summary>
            /// Dynamic entry type
            /// </summary>
            public RawElf.Elf64_Sxword d_tag;
            
            public RawElf.Elf64_Dyn.Elf64_Dyn_union_d_un d_un;
        }
        
        /// <summary>
        /// Version definition sections.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Verdef
        {
            /// <summary>
            /// Version revision
            /// </summary>
            public RawElf.Elf32_Half vd_version;
            
            /// <summary>
            /// Version information
            /// </summary>
            public RawElf.Elf32_Half vd_flags;
            
            /// <summary>
            /// Version Index
            /// </summary>
            public RawElf.Elf32_Half vd_ndx;
            
            /// <summary>
            /// Number of associated aux entries
            /// </summary>
            public RawElf.Elf32_Half vd_cnt;
            
            /// <summary>
            /// Version name hash value
            /// </summary>
            public RawElf.Elf32_Word vd_hash;
            
            /// <summary>
            /// Offset in bytes to verdaux array
            /// </summary>
            public RawElf.Elf32_Word vd_aux;
            
            /// <summary>
            /// Offset in bytes to next verdef
            /// entry
            /// </summary>
            public RawElf.Elf32_Word vd_next;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Verdef
        {
            /// <summary>
            /// Version revision
            /// </summary>
            public RawElf.Elf64_Half vd_version;
            
            /// <summary>
            /// Version information
            /// </summary>
            public RawElf.Elf64_Half vd_flags;
            
            /// <summary>
            /// Version Index
            /// </summary>
            public RawElf.Elf64_Half vd_ndx;
            
            /// <summary>
            /// Number of associated aux entries
            /// </summary>
            public RawElf.Elf64_Half vd_cnt;
            
            /// <summary>
            /// Version name hash value
            /// </summary>
            public RawElf.Elf64_Word vd_hash;
            
            /// <summary>
            /// Offset in bytes to verdaux array
            /// </summary>
            public RawElf.Elf64_Word vd_aux;
            
            /// <summary>
            /// Offset in bytes to next verdef
            /// entry
            /// </summary>
            public RawElf.Elf64_Word vd_next;
        }
        
        /// <summary>
        /// Auxialiary version information.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Verdaux
        {
            /// <summary>
            /// Version or dependency names
            /// </summary>
            public RawElf.Elf32_Word vda_name;
            
            /// <summary>
            /// Offset in bytes to next verdaux
            /// entry
            /// </summary>
            public RawElf.Elf32_Word vda_next;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Verdaux
        {
            /// <summary>
            /// Version or dependency names
            /// </summary>
            public RawElf.Elf64_Word vda_name;
            
            /// <summary>
            /// Offset in bytes to next verdaux
            /// entry
            /// </summary>
            public RawElf.Elf64_Word vda_next;
        }
        
        /// <summary>
        /// Version dependency section.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Verneed
        {
            /// <summary>
            /// Version of structure
            /// </summary>
            public RawElf.Elf32_Half vn_version;
            
            /// <summary>
            /// Number of associated aux entries
            /// </summary>
            public RawElf.Elf32_Half vn_cnt;
            
            /// <summary>
            /// Offset of filename for this
            /// dependency
            /// </summary>
            public RawElf.Elf32_Word vn_file;
            
            /// <summary>
            /// Offset in bytes to vernaux array
            /// </summary>
            public RawElf.Elf32_Word vn_aux;
            
            /// <summary>
            /// Offset in bytes to next verneed
            /// entry
            /// </summary>
            public RawElf.Elf32_Word vn_next;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Verneed
        {
            /// <summary>
            /// Version of structure
            /// </summary>
            public RawElf.Elf64_Half vn_version;
            
            /// <summary>
            /// Number of associated aux entries
            /// </summary>
            public RawElf.Elf64_Half vn_cnt;
            
            /// <summary>
            /// Offset of filename for this
            /// dependency
            /// </summary>
            public RawElf.Elf64_Word vn_file;
            
            /// <summary>
            /// Offset in bytes to vernaux array
            /// </summary>
            public RawElf.Elf64_Word vn_aux;
            
            /// <summary>
            /// Offset in bytes to next verneed
            /// entry
            /// </summary>
            public RawElf.Elf64_Word vn_next;
        }
        
        /// <summary>
        /// Auxiliary needed version information.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Vernaux
        {
            /// <summary>
            /// Hash value of dependency name
            /// </summary>
            public RawElf.Elf32_Word vna_hash;
            
            /// <summary>
            /// Dependency specific information
            /// </summary>
            public RawElf.Elf32_Half vna_flags;
            
            /// <summary>
            /// Unused
            /// </summary>
            public RawElf.Elf32_Half vna_other;
            
            /// <summary>
            /// Dependency name string offset
            /// </summary>
            public RawElf.Elf32_Word vna_name;
            
            /// <summary>
            /// Offset in bytes to next vernaux
            /// entry
            /// </summary>
            public RawElf.Elf32_Word vna_next;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Vernaux
        {
            /// <summary>
            /// Hash value of dependency name
            /// </summary>
            public RawElf.Elf64_Word vna_hash;
            
            /// <summary>
            /// Dependency specific information
            /// </summary>
            public RawElf.Elf64_Half vna_flags;
            
            /// <summary>
            /// Unused
            /// </summary>
            public RawElf.Elf64_Half vna_other;
            
            /// <summary>
            /// Dependency name string offset
            /// </summary>
            public RawElf.Elf64_Word vna_name;
            
            /// <summary>
            /// Offset in bytes to next vernaux
            /// entry
            /// </summary>
            public RawElf.Elf64_Word vna_next;
        }
        
        /// <summary>
        /// This vector is normally only used by the program interpreter.  The
        /// usual definition in an ABI supplement uses the name auxv_t.  The
        /// vector is not usually defined in a standard 
        /// &lt;elf
        /// .h&gt; file, but it
        /// can't hurt.  We rename it to avoid conflicts.  The sizes of these
        /// types are an arrangement between the exec server and the program
        /// interpreter, so we don't fully specify them here.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_auxv_t
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct Elf32_auxv_t_union_a_un
            {
                /// <summary>
                /// Integer value
                /// </summary>
                [FieldOffset(0)]
                public uint a_val;
            }
            
            /// <summary>
            /// Entry type
            /// </summary>
            public uint a_type;
            
            public RawElf.Elf32_auxv_t.Elf32_auxv_t_union_a_un a_un;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_auxv_t
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public partial struct Elf64_auxv_t_union_a_un
            {
                /// <summary>
                /// Integer value
                /// </summary>
                [FieldOffset(0)]
                public ulong a_val;
            }
            
            /// <summary>
            /// Entry type
            /// </summary>
            public ulong a_type;
            
            public RawElf.Elf64_auxv_t.Elf64_auxv_t_union_a_un a_un;
        }
        
        /// <summary>
        /// Note section contents.  Each entry in the note section begins with
        /// a header of a fixed form.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Nhdr
        {
            /// <summary>
            /// Length of the note's name.
            /// </summary>
            public RawElf.Elf32_Word n_namesz;
            
            /// <summary>
            /// Length of the note's descriptor.
            /// </summary>
            public RawElf.Elf32_Word n_descsz;
            
            /// <summary>
            /// Type of the note.
            /// </summary>
            public RawElf.Elf32_Word n_type;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Nhdr
        {
            /// <summary>
            /// Length of the note's name.
            /// </summary>
            public RawElf.Elf64_Word n_namesz;
            
            /// <summary>
            /// Length of the note's descriptor.
            /// </summary>
            public RawElf.Elf64_Word n_descsz;
            
            /// <summary>
            /// Type of the note.
            /// </summary>
            public RawElf.Elf64_Word n_type;
        }
        
        /// <summary>
        /// Move records.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Move
        {
            /// <summary>
            /// Symbol value.
            /// </summary>
            public RawElf.Elf32_Xword m_value;
            
            /// <summary>
            /// Size and index.
            /// </summary>
            public RawElf.Elf32_Word m_info;
            
            /// <summary>
            /// Symbol offset.
            /// </summary>
            public RawElf.Elf32_Word m_poffset;
            
            /// <summary>
            /// Repeat count.
            /// </summary>
            public RawElf.Elf32_Half m_repeat;
            
            /// <summary>
            /// Stride info.
            /// </summary>
            public RawElf.Elf32_Half m_stride;
        }
        
        /// <summary>
        /// Types for signed and unsigned 64-bit quantities.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Xword : IEquatable<Elf32_Xword>
        {
            public Elf32_Xword(ulong value) => this.Value = value;
            
            public readonly ulong Value;
            
            public bool Equals(Elf32_Xword other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Xword other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator ulong(Elf32_Xword from) => from.Value;
            
            public static implicit operator Elf32_Xword(ulong from) => new Elf32_Xword(from);
            
            public static bool operator ==(Elf32_Xword left, Elf32_Xword right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Xword left, Elf32_Xword right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Move
        {
            /// <summary>
            /// Symbol value.
            /// </summary>
            public RawElf.Elf64_Xword m_value;
            
            /// <summary>
            /// Size and index.
            /// </summary>
            public RawElf.Elf64_Xword m_info;
            
            /// <summary>
            /// Symbol offset.
            /// </summary>
            public RawElf.Elf64_Xword m_poffset;
            
            /// <summary>
            /// Repeat count.
            /// </summary>
            public RawElf.Elf64_Half m_repeat;
            
            /// <summary>
            /// Stride info.
            /// </summary>
            public RawElf.Elf64_Half m_stride;
        }
        
        /// <summary>
        /// Entries found in sections of type SHT_MIPS_GPTAB.
        /// </summary>
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
        public partial struct Elf32_gptab
        {
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public partial struct Elf32_gptab_gt_header
            {
                /// <summary>
                /// -G value used for compilation.
                /// </summary>
                public RawElf.Elf32_Word gt_current_g_value;
                
                /// <summary>
                /// Not used.
                /// </summary>
                public RawElf.Elf32_Word gt_unused;
            }
            
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public partial struct Elf32_gptab_gt_entry
            {
                /// <summary>
                /// If this value were used for -G.
                /// </summary>
                public RawElf.Elf32_Word gt_g_value;
                
                /// <summary>
                /// This many bytes would be used.
                /// </summary>
                public RawElf.Elf32_Word gt_bytes;
            }
            
            /// <summary>
            /// First entry in section.
            /// </summary>
            [FieldOffset(0)]
            public RawElf.Elf32_gptab.Elf32_gptab_gt_header gt_header;
            
            /// <summary>
            /// Subsequent entries in section.
            /// </summary>
            [FieldOffset(0)]
            public RawElf.Elf32_gptab.Elf32_gptab_gt_entry gt_entry;
        }
        
        /// <summary>
        /// Entry found in sections of type SHT_MIPS_REGINFO.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct Elf32_RegInfo
        {
            /// <summary>
            /// General registers used.
            /// </summary>
            public RawElf.Elf32_Word ri_gprmask;
            
            /// <summary>
            /// Coprocessor registers used.
            /// </summary>
            public fixed uint ri_cprmask[4];
            
            /// <summary>
            /// $gp register value.
            /// </summary>
            public RawElf.Elf32_Sword ri_gp_value;
        }
        
        /// <summary>
        /// Entries found in sections of type SHT_MIPS_OPTIONS.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf_Options
        {
            /// <summary>
            /// Determines interpretation of the
            /// variable part of descriptor.
            /// </summary>
            public byte kind;
            
            /// <summary>
            /// Size of descriptor, including header.
            /// </summary>
            public byte size;
            
            /// <summary>
            /// Section header index of section affected,
            /// 0 for global options.
            /// </summary>
            public RawElf.Elf32_Section section;
            
            /// <summary>
            /// Kind-specific information.
            /// </summary>
            public RawElf.Elf32_Word info;
        }
        
        /// <summary>
        /// Entry found in `.options' section.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf_Options_Hw
        {
            /// <summary>
            /// Extra flags.
            /// </summary>
            public RawElf.Elf32_Word hwp_flags1;
            
            /// <summary>
            /// Extra flags.
            /// </summary>
            public RawElf.Elf32_Word hwp_flags2;
        }
        
        /// <summary>
        /// Entries found in sections of type SHT_MIPS_LIBLIST.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf32_Lib
        {
            /// <summary>
            /// Name (string table index)
            /// </summary>
            public RawElf.Elf32_Word l_name;
            
            /// <summary>
            /// Timestamp
            /// </summary>
            public RawElf.Elf32_Word l_time_stamp;
            
            /// <summary>
            /// Checksum
            /// </summary>
            public RawElf.Elf32_Word l_checksum;
            
            /// <summary>
            /// Interface version
            /// </summary>
            public RawElf.Elf32_Word l_version;
            
            /// <summary>
            /// Flags
            /// </summary>
            public RawElf.Elf32_Word l_flags;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf64_Lib
        {
            /// <summary>
            /// Name (string table index)
            /// </summary>
            public RawElf.Elf64_Word l_name;
            
            /// <summary>
            /// Timestamp
            /// </summary>
            public RawElf.Elf64_Word l_time_stamp;
            
            /// <summary>
            /// Checksum
            /// </summary>
            public RawElf.Elf64_Word l_checksum;
            
            /// <summary>
            /// Interface version
            /// </summary>
            public RawElf.Elf64_Word l_version;
            
            /// <summary>
            /// Flags
            /// </summary>
            public RawElf.Elf64_Word l_flags;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct Elf_MIPS_ABIFlags_v0
        {
            /// <summary>
            /// Version of flags structure.
            /// </summary>
            public RawElf.Elf32_Half version;
            
            /// <summary>
            /// The level of the ISA: 1-5, 32, 64.
            /// </summary>
            public byte isa_level;
            
            /// <summary>
            /// The revision of ISA: 0 for MIPS V and below, 1-n otherwise.
            /// </summary>
            public byte isa_rev;
            
            /// <summary>
            /// The size of general purpose registers.
            /// </summary>
            public byte gpr_size;
            
            /// <summary>
            /// The size of co-processor 1 registers.
            /// </summary>
            public byte cpr1_size;
            
            /// <summary>
            /// The size of co-processor 2 registers.
            /// </summary>
            public byte cpr2_size;
            
            /// <summary>
            /// The floating-point ABI.
            /// </summary>
            public byte fp_abi;
            
            /// <summary>
            /// Processor-specific extension.
            /// </summary>
            public RawElf.Elf32_Word isa_ext;
            
            /// <summary>
            /// Mask of ASEs used.
            /// </summary>
            public RawElf.Elf32_Word ases;
            
            /// <summary>
            /// Mask of general flags.
            /// </summary>
            public RawElf.Elf32_Word flags1;
            
            public RawElf.Elf32_Word flags2;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Sword : IEquatable<Elf64_Sword>
        {
            public Elf64_Sword(int value) => this.Value = value;
            
            public readonly int Value;
            
            public bool Equals(Elf64_Sword other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Sword other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator int(Elf64_Sword from) => from.Value;
            
            public static implicit operator Elf64_Sword(int from) => new Elf64_Sword(from);
            
            public static bool operator ==(Elf64_Sword left, Elf64_Sword right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Sword left, Elf64_Sword right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Sxword : IEquatable<Elf32_Sxword>
        {
            public Elf32_Sxword(long value) => this.Value = value;
            
            public readonly long Value;
            
            public bool Equals(Elf32_Sxword other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Sxword other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator long(Elf32_Sxword from) => from.Value;
            
            public static implicit operator Elf32_Sxword(long from) => new Elf32_Sxword(from);
            
            public static bool operator ==(Elf32_Sxword left, Elf32_Sxword right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Sxword left, Elf32_Sxword right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Type for version symbol information.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Versym : IEquatable<Elf32_Versym>
        {
            public Elf32_Versym(RawElf.Elf32_Half value) => this.Value = value;
            
            public readonly RawElf.Elf32_Half Value;
            
            public bool Equals(Elf32_Versym other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Versym other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator RawElf.Elf32_Half(Elf32_Versym from) => from.Value;
            
            public static implicit operator Elf32_Versym(RawElf.Elf32_Half from) => new Elf32_Versym(from);
            
            public static bool operator ==(Elf32_Versym left, Elf32_Versym right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Versym left, Elf32_Versym right) => !left.Equals(right);
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf64_Versym : IEquatable<Elf64_Versym>
        {
            public Elf64_Versym(RawElf.Elf64_Half value) => this.Value = value;
            
            public readonly RawElf.Elf64_Half Value;
            
            public bool Equals(Elf64_Versym other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf64_Versym other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator RawElf.Elf64_Half(Elf64_Versym from) => from.Value;
            
            public static implicit operator Elf64_Versym(RawElf.Elf64_Half from) => new Elf64_Versym(from);
            
            public static bool operator ==(Elf64_Versym left, Elf64_Versym right) => left.Equals(right);
            
            public static bool operator !=(Elf64_Versym left, Elf64_Versym right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Entries found in sections of type SHT_MIPS_CONFLICT.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct Elf32_Conflict : IEquatable<Elf32_Conflict>
        {
            public Elf32_Conflict(RawElf.Elf32_Addr value) => this.Value = value;
            
            public readonly RawElf.Elf32_Addr Value;
            
            public bool Equals(Elf32_Conflict other) =>  Value.Equals(other.Value);
            
            public override bool Equals(object obj) => obj is Elf32_Conflict other && Equals(other);
            
            public override int GetHashCode() => Value.GetHashCode();
            
            public override string ToString() => Value.ToString();
            
            public static implicit operator RawElf.Elf32_Addr(Elf32_Conflict from) => from.Value;
            
            public static implicit operator Elf32_Conflict(RawElf.Elf32_Addr from) => new Elf32_Conflict(from);
            
            public static bool operator ==(Elf32_Conflict left, Elf32_Conflict right) => left.Equals(right);
            
            public static bool operator !=(Elf32_Conflict left, Elf32_Conflict right) => !left.Equals(right);
        }
        
        public const byte EI_NIDENT = 16;
        
        /// <summary>
        /// File identification byte 0 index
        /// </summary>
        public const byte EI_MAG0 = 0;
        
        /// <summary>
        /// Magic number byte 0
        /// </summary>
        public const byte ELFMAG0 = 127;
        
        /// <summary>
        /// File identification byte 1 index
        /// </summary>
        public const byte EI_MAG1 = 1;
        
        /// <summary>
        /// Magic number byte 1
        /// </summary>
        public const byte ELFMAG1 = 69;
        
        /// <summary>
        /// File identification byte 2 index
        /// </summary>
        public const byte EI_MAG2 = 2;
        
        /// <summary>
        /// Magic number byte 2
        /// </summary>
        public const byte ELFMAG2 = 76;
        
        /// <summary>
        /// File identification byte 3 index
        /// </summary>
        public const byte EI_MAG3 = 3;
        
        /// <summary>
        /// Magic number byte 3
        /// </summary>
        public const byte ELFMAG3 = 70;
        
        /// <summary>
        /// File class byte index
        /// </summary>
        public const byte EI_CLASS = 4;
        
        /// <summary>
        /// Invalid class
        /// </summary>
        public const byte ELFCLASSNONE = 0;
        
        /// <summary>
        /// 32-bit objects
        /// </summary>
        public const byte ELFCLASS32 = 1;
        
        /// <summary>
        /// 64-bit objects
        /// </summary>
        public const byte ELFCLASS64 = 2;
        
        public const byte ELFCLASSNUM = 3;
        
        /// <summary>
        /// Data encoding byte index
        /// </summary>
        public const byte EI_DATA = 5;
        
        /// <summary>
        /// Invalid data encoding
        /// </summary>
        public const byte ELFDATANONE = 0;
        
        /// <summary>
        /// 2's complement, little endian
        /// </summary>
        public const byte ELFDATA2LSB = 1;
        
        /// <summary>
        /// 2's complement, big endian
        /// </summary>
        public const byte ELFDATA2MSB = 2;
        
        public const byte ELFDATANUM = 3;
        
        /// <summary>
        /// File version byte index
        /// </summary>
        public const byte EI_VERSION = 6;
        
        /// <summary>
        /// OS ABI identification
        /// </summary>
        public const byte EI_OSABI = 7;
        
        /// <summary>
        /// UNIX System V ABI
        /// </summary>
        public const byte ELFOSABI_NONE = 0;
        
        /// <summary>
        /// Alias.
        /// </summary>
        public const byte ELFOSABI_SYSV = 0;
        
        /// <summary>
        /// HP-UX
        /// </summary>
        public const byte ELFOSABI_HPUX = 1;
        
        /// <summary>
        /// NetBSD.
        /// </summary>
        public const byte ELFOSABI_NETBSD = 2;
        
        /// <summary>
        /// Object uses GNU ELF extensions.
        /// </summary>
        public const byte ELFOSABI_GNU = 3;
        
        /// <summary>
        /// Compatibility alias.
        /// </summary>
        public const byte ELFOSABI_LINUX = 3;
        
        /// <summary>
        /// Sun Solaris.
        /// </summary>
        public const byte ELFOSABI_SOLARIS = 6;
        
        /// <summary>
        /// IBM AIX.
        /// </summary>
        public const byte ELFOSABI_AIX = 7;
        
        /// <summary>
        /// SGI Irix.
        /// </summary>
        public const byte ELFOSABI_IRIX = 8;
        
        /// <summary>
        /// FreeBSD.
        /// </summary>
        public const byte ELFOSABI_FREEBSD = 9;
        
        /// <summary>
        /// Compaq TRU64 UNIX.
        /// </summary>
        public const byte ELFOSABI_TRU64 = 10;
        
        /// <summary>
        /// Novell Modesto.
        /// </summary>
        public const byte ELFOSABI_MODESTO = 11;
        
        /// <summary>
        /// OpenBSD.
        /// </summary>
        public const byte ELFOSABI_OPENBSD = 12;
        
        /// <summary>
        /// ARM EABI
        /// </summary>
        public const byte ELFOSABI_ARM_AEABI = 64;
        
        /// <summary>
        /// ARM
        /// </summary>
        public const byte ELFOSABI_ARM = 97;
        
        /// <summary>
        /// Standalone (embedded) application
        /// </summary>
        public const byte ELFOSABI_STANDALONE = 255;
        
        /// <summary>
        /// ABI version
        /// </summary>
        public const byte EI_ABIVERSION = 8;
        
        /// <summary>
        /// Byte index of padding bytes
        /// </summary>
        public const byte EI_PAD = 9;
        
        /// <summary>
        /// No file type
        /// </summary>
        public const ushort ET_NONE = 0;
        
        /// <summary>
        /// Relocatable file
        /// </summary>
        public const ushort ET_REL = 1;
        
        /// <summary>
        /// Executable file
        /// </summary>
        public const ushort ET_EXEC = 2;
        
        /// <summary>
        /// Shared object file
        /// </summary>
        public const ushort ET_DYN = 3;
        
        /// <summary>
        /// Core file
        /// </summary>
        public const ushort ET_CORE = 4;
        
        /// <summary>
        /// Number of defined types
        /// </summary>
        public const ushort ET_NUM = 5;
        
        /// <summary>
        /// OS-specific range start
        /// </summary>
        public const ushort ET_LOOS = 65024;
        
        /// <summary>
        /// OS-specific range end
        /// </summary>
        public const ushort ET_HIOS = 65279;
        
        /// <summary>
        /// Processor-specific range start
        /// </summary>
        public const ushort ET_LOPROC = 65280;
        
        /// <summary>
        /// Processor-specific range end
        /// </summary>
        public const ushort ET_HIPROC = 65535;
        
        /// <summary>
        /// No machine
        /// </summary>
        public const ushort EM_NONE = 0;
        
        /// <summary>
        /// AT
        /// &amp;T
        /// WE 32100
        /// </summary>
        public const ushort EM_M32 = 1;
        
        /// <summary>
        /// SUN SPARC
        /// </summary>
        public const ushort EM_SPARC = 2;
        
        /// <summary>
        /// Intel 80386
        /// </summary>
        public const ushort EM_386 = 3;
        
        /// <summary>
        /// Motorola m68k family
        /// </summary>
        public const ushort EM_68K = 4;
        
        /// <summary>
        /// Motorola m88k family
        /// </summary>
        public const ushort EM_88K = 5;
        
        /// <summary>
        /// Intel 80860
        /// </summary>
        public const ushort EM_860 = 7;
        
        /// <summary>
        /// MIPS R3000 big-endian
        /// </summary>
        public const ushort EM_MIPS = 8;
        
        /// <summary>
        /// IBM System/370
        /// </summary>
        public const ushort EM_S370 = 9;
        
        /// <summary>
        /// MIPS R3000 little-endian
        /// </summary>
        public const ushort EM_MIPS_RS3_LE = 10;
        
        /// <summary>
        /// HPPA
        /// </summary>
        public const ushort EM_PARISC = 15;
        
        /// <summary>
        /// Fujitsu VPP500
        /// </summary>
        public const ushort EM_VPP500 = 17;
        
        /// <summary>
        /// Sun's "v8plus"
        /// </summary>
        public const ushort EM_SPARC32PLUS = 18;
        
        /// <summary>
        /// Intel 80960
        /// </summary>
        public const ushort EM_960 = 19;
        
        /// <summary>
        /// PowerPC
        /// </summary>
        public const ushort EM_PPC = 20;
        
        /// <summary>
        /// PowerPC 64-bit
        /// </summary>
        public const ushort EM_PPC64 = 21;
        
        /// <summary>
        /// IBM S390
        /// </summary>
        public const ushort EM_S390 = 22;
        
        /// <summary>
        /// NEC V800 series
        /// </summary>
        public const ushort EM_V800 = 36;
        
        /// <summary>
        /// Fujitsu FR20
        /// </summary>
        public const ushort EM_FR20 = 37;
        
        /// <summary>
        /// TRW RH-32
        /// </summary>
        public const ushort EM_RH32 = 38;
        
        /// <summary>
        /// Motorola RCE
        /// </summary>
        public const ushort EM_RCE = 39;
        
        /// <summary>
        /// ARM
        /// </summary>
        public const ushort EM_ARM = 40;
        
        /// <summary>
        /// Digital Alpha
        /// </summary>
        public const ushort EM_FAKE_ALPHA = 41;
        
        /// <summary>
        /// Hitachi SH
        /// </summary>
        public const ushort EM_SH = 42;
        
        /// <summary>
        /// SPARC v9 64-bit
        /// </summary>
        public const ushort EM_SPARCV9 = 43;
        
        /// <summary>
        /// Siemens Tricore
        /// </summary>
        public const ushort EM_TRICORE = 44;
        
        /// <summary>
        /// Argonaut RISC Core
        /// </summary>
        public const ushort EM_ARC = 45;
        
        /// <summary>
        /// Hitachi H8/300
        /// </summary>
        public const ushort EM_H8_300 = 46;
        
        /// <summary>
        /// Hitachi H8/300H
        /// </summary>
        public const ushort EM_H8_300H = 47;
        
        /// <summary>
        /// Hitachi H8S
        /// </summary>
        public const ushort EM_H8S = 48;
        
        /// <summary>
        /// Hitachi H8/500
        /// </summary>
        public const ushort EM_H8_500 = 49;
        
        /// <summary>
        /// Intel Merced
        /// </summary>
        public const ushort EM_IA_64 = 50;
        
        /// <summary>
        /// Stanford MIPS-X
        /// </summary>
        public const ushort EM_MIPS_X = 51;
        
        /// <summary>
        /// Motorola Coldfire
        /// </summary>
        public const ushort EM_COLDFIRE = 52;
        
        /// <summary>
        /// Motorola M68HC12
        /// </summary>
        public const ushort EM_68HC12 = 53;
        
        /// <summary>
        /// Fujitsu MMA Multimedia Accelerator
        /// </summary>
        public const ushort EM_MMA = 54;
        
        /// <summary>
        /// Siemens PCP
        /// </summary>
        public const ushort EM_PCP = 55;
        
        /// <summary>
        /// Sony nCPU embeeded RISC
        /// </summary>
        public const ushort EM_NCPU = 56;
        
        /// <summary>
        /// Denso NDR1 microprocessor
        /// </summary>
        public const ushort EM_NDR1 = 57;
        
        /// <summary>
        /// Motorola Start*Core processor
        /// </summary>
        public const ushort EM_STARCORE = 58;
        
        /// <summary>
        /// Toyota ME16 processor
        /// </summary>
        public const ushort EM_ME16 = 59;
        
        /// <summary>
        /// STMicroelectronic ST100 processor
        /// </summary>
        public const ushort EM_ST100 = 60;
        
        /// <summary>
        /// Advanced Logic Corp. Tinyj emb.fam
        /// </summary>
        public const ushort EM_TINYJ = 61;
        
        /// <summary>
        /// AMD x86-64 architecture
        /// </summary>
        public const ushort EM_X86_64 = 62;
        
        /// <summary>
        /// Sony DSP Processor
        /// </summary>
        public const ushort EM_PDSP = 63;
        
        /// <summary>
        /// Siemens FX66 microcontroller
        /// </summary>
        public const ushort EM_FX66 = 66;
        
        /// <summary>
        /// STMicroelectronics ST9+ 8/16 mc
        /// </summary>
        public const ushort EM_ST9PLUS = 67;
        
        /// <summary>
        /// STmicroelectronics ST7 8 bit mc
        /// </summary>
        public const ushort EM_ST7 = 68;
        
        /// <summary>
        /// Motorola MC68HC16 microcontroller
        /// </summary>
        public const ushort EM_68HC16 = 69;
        
        /// <summary>
        /// Motorola MC68HC11 microcontroller
        /// </summary>
        public const ushort EM_68HC11 = 70;
        
        /// <summary>
        /// Motorola MC68HC08 microcontroller
        /// </summary>
        public const ushort EM_68HC08 = 71;
        
        /// <summary>
        /// Motorola MC68HC05 microcontroller
        /// </summary>
        public const ushort EM_68HC05 = 72;
        
        /// <summary>
        /// Silicon Graphics SVx
        /// </summary>
        public const ushort EM_SVX = 73;
        
        /// <summary>
        /// STMicroelectronics ST19 8 bit mc
        /// </summary>
        public const ushort EM_ST19 = 74;
        
        /// <summary>
        /// Digital VAX
        /// </summary>
        public const ushort EM_VAX = 75;
        
        /// <summary>
        /// Axis Communications 32-bit embedded processor
        /// </summary>
        public const ushort EM_CRIS = 76;
        
        /// <summary>
        /// Infineon Technologies 32-bit embedded processor
        /// </summary>
        public const ushort EM_JAVELIN = 77;
        
        /// <summary>
        /// Element 14 64-bit DSP Processor
        /// </summary>
        public const ushort EM_FIREPATH = 78;
        
        /// <summary>
        /// LSI Logic 16-bit DSP Processor
        /// </summary>
        public const ushort EM_ZSP = 79;
        
        /// <summary>
        /// Donald Knuth's educational 64-bit processor
        /// </summary>
        public const ushort EM_MMIX = 80;
        
        /// <summary>
        /// Harvard University machine-independent object files
        /// </summary>
        public const ushort EM_HUANY = 81;
        
        /// <summary>
        /// SiTera Prism
        /// </summary>
        public const ushort EM_PRISM = 82;
        
        /// <summary>
        /// Atmel AVR 8-bit microcontroller
        /// </summary>
        public const ushort EM_AVR = 83;
        
        /// <summary>
        /// Fujitsu FR30
        /// </summary>
        public const ushort EM_FR30 = 84;
        
        /// <summary>
        /// Mitsubishi D10V
        /// </summary>
        public const ushort EM_D10V = 85;
        
        /// <summary>
        /// Mitsubishi D30V
        /// </summary>
        public const ushort EM_D30V = 86;
        
        /// <summary>
        /// NEC v850
        /// </summary>
        public const ushort EM_V850 = 87;
        
        /// <summary>
        /// Mitsubishi M32R
        /// </summary>
        public const ushort EM_M32R = 88;
        
        /// <summary>
        /// Matsushita MN10300
        /// </summary>
        public const ushort EM_MN10300 = 89;
        
        /// <summary>
        /// Matsushita MN10200
        /// </summary>
        public const ushort EM_MN10200 = 90;
        
        /// <summary>
        /// picoJava
        /// </summary>
        public const ushort EM_PJ = 91;
        
        /// <summary>
        /// OpenRISC 32-bit embedded processor
        /// </summary>
        public const ushort EM_OPENRISC = 92;
        
        /// <summary>
        /// ARC Cores Tangent-A5
        /// </summary>
        public const ushort EM_ARC_A5 = 93;
        
        /// <summary>
        /// Tensilica Xtensa Architecture
        /// </summary>
        public const ushort EM_XTENSA = 94;
        
        /// <summary>
        /// Altera Nios II
        /// </summary>
        public const ushort EM_ALTERA_NIOS2 = 113;
        
        /// <summary>
        /// ARM AARCH64
        /// </summary>
        public const ushort EM_AARCH64 = 183;
        
        /// <summary>
        /// Tilera TILEPro
        /// </summary>
        public const ushort EM_TILEPRO = 188;
        
        /// <summary>
        /// Xilinx MicroBlaze
        /// </summary>
        public const ushort EM_MICROBLAZE = 189;
        
        /// <summary>
        /// Tilera TILE-Gx
        /// </summary>
        public const ushort EM_TILEGX = 191;
        
        public const ushort EM_NUM = 192;
        
        public const ushort EM_ALPHA = 36902;
        
        /// <summary>
        /// Invalid ELF version
        /// </summary>
        public const byte EV_NONE = 0;
        
        /// <summary>
        /// Current version
        /// </summary>
        public const byte EV_CURRENT = 1;
        
        public const byte EV_NUM = 2;
        
        /// <summary>
        /// Undefined section
        /// </summary>
        public const uint SHN_UNDEF = 0;
        
        /// <summary>
        /// Start of reserved indices
        /// </summary>
        public const uint SHN_LORESERVE = 65280;
        
        /// <summary>
        /// Start of processor-specific
        /// </summary>
        public const uint SHN_LOPROC = 65280;
        
        /// <summary>
        /// Order section before all others (Solaris).
        /// </summary>
        public const uint SHN_BEFORE = 65280;
        
        /// <summary>
        /// Order section after all others (Solaris).
        /// </summary>
        public const uint SHN_AFTER = 65281;
        
        /// <summary>
        /// End of processor-specific
        /// </summary>
        public const uint SHN_HIPROC = 65311;
        
        /// <summary>
        /// Start of OS-specific
        /// </summary>
        public const uint SHN_LOOS = 65312;
        
        /// <summary>
        /// End of OS-specific
        /// </summary>
        public const uint SHN_HIOS = 65343;
        
        /// <summary>
        /// Associated symbol is absolute
        /// </summary>
        public const uint SHN_ABS = 65521;
        
        /// <summary>
        /// Associated symbol is common
        /// </summary>
        public const uint SHN_COMMON = 65522;
        
        /// <summary>
        /// Index is in extra table.
        /// </summary>
        public const uint SHN_XINDEX = 65535;
        
        /// <summary>
        /// End of reserved indices
        /// </summary>
        public const uint SHN_HIRESERVE = 65535;
        
        /// <summary>
        /// Section header table entry unused
        /// </summary>
        public const uint SHT_NULL = 0;
        
        /// <summary>
        /// Program data
        /// </summary>
        public const uint SHT_PROGBITS = 1;
        
        /// <summary>
        /// Symbol table
        /// </summary>
        public const uint SHT_SYMTAB = 2;
        
        /// <summary>
        /// String table
        /// </summary>
        public const uint SHT_STRTAB = 3;
        
        /// <summary>
        /// Relocation entries with addends
        /// </summary>
        public const uint SHT_RELA = 4;
        
        /// <summary>
        /// Symbol hash table
        /// </summary>
        public const uint SHT_HASH = 5;
        
        /// <summary>
        /// Dynamic linking information
        /// </summary>
        public const uint SHT_DYNAMIC = 6;
        
        /// <summary>
        /// Notes
        /// </summary>
        public const uint SHT_NOTE = 7;
        
        /// <summary>
        /// Program space with no data (bss)
        /// </summary>
        public const uint SHT_NOBITS = 8;
        
        /// <summary>
        /// Relocation entries, no addends
        /// </summary>
        public const uint SHT_REL = 9;
        
        /// <summary>
        /// Reserved
        /// </summary>
        public const uint SHT_SHLIB = 10;
        
        /// <summary>
        /// Dynamic linker symbol table
        /// </summary>
        public const uint SHT_DYNSYM = 11;
        
        /// <summary>
        /// Array of constructors
        /// </summary>
        public const uint SHT_INIT_ARRAY = 14;
        
        /// <summary>
        /// Array of destructors
        /// </summary>
        public const uint SHT_FINI_ARRAY = 15;
        
        /// <summary>
        /// Array of pre-constructors
        /// </summary>
        public const uint SHT_PREINIT_ARRAY = 16;
        
        /// <summary>
        /// Section group
        /// </summary>
        public const uint SHT_GROUP = 17;
        
        /// <summary>
        /// Extended section indeces
        /// </summary>
        public const uint SHT_SYMTAB_SHNDX = 18;
        
        /// <summary>
        /// Number of defined types.
        /// </summary>
        public const uint SHT_NUM = 19;
        
        /// <summary>
        /// Start OS-specific.
        /// </summary>
        public const uint SHT_LOOS = 1610612736;
        
        /// <summary>
        /// Object attributes.
        /// </summary>
        public const uint SHT_GNU_ATTRIBUTES = 1879048181;
        
        /// <summary>
        /// GNU-style hash table.
        /// </summary>
        public const uint SHT_GNU_HASH = 1879048182;
        
        /// <summary>
        /// Prelink library list
        /// </summary>
        public const uint SHT_GNU_LIBLIST = 1879048183;
        
        /// <summary>
        /// Checksum for DSO content.
        /// </summary>
        public const uint SHT_CHECKSUM = 1879048184;
        
        /// <summary>
        /// Sun-specific low bound.
        /// </summary>
        public const uint SHT_LOSUNW = 1879048186;
        
        public const uint SHT_SUNW_move = 1879048186;
        
        public const uint SHT_SUNW_COMDAT = 1879048187;
        
        public const uint SHT_SUNW_syminfo = 1879048188;
        
        /// <summary>
        /// Version definition section.
        /// </summary>
        public const uint SHT_GNU_verdef = 1879048189;
        
        /// <summary>
        /// Version needs section.
        /// </summary>
        public const uint SHT_GNU_verneed = 1879048190;
        
        /// <summary>
        /// Version symbol table.
        /// </summary>
        public const uint SHT_GNU_versym = 1879048191;
        
        /// <summary>
        /// Sun-specific high bound.
        /// </summary>
        public const uint SHT_HISUNW = 1879048191;
        
        /// <summary>
        /// End OS-specific type
        /// </summary>
        public const uint SHT_HIOS = 1879048191;
        
        /// <summary>
        /// Start of processor-specific
        /// </summary>
        public const uint SHT_LOPROC = 1879048192;
        
        /// <summary>
        /// End of processor-specific
        /// </summary>
        public const uint SHT_HIPROC = 2147483647;
        
        /// <summary>
        /// Start of application-specific
        /// </summary>
        public const uint SHT_LOUSER = 0x80000000;
        
        /// <summary>
        /// End of application-specific
        /// </summary>
        public const uint SHT_HIUSER = 0x8fffffff;
        
        /// <summary>
        /// Writable
        /// </summary>
        public const uint SHF_WRITE = 1;
        
        /// <summary>
        /// Occupies memory during execution
        /// </summary>
        public const uint SHF_ALLOC = 2;
        
        /// <summary>
        /// Executable
        /// </summary>
        public const uint SHF_EXECINSTR = 4;
        
        /// <summary>
        /// Might be merged
        /// </summary>
        public const uint SHF_MERGE = 16;
        
        /// <summary>
        /// Contains nul-terminated strings
        /// </summary>
        public const uint SHF_STRINGS = 32;
        
        /// <summary>
        /// `sh_info' contains SHT index
        /// </summary>
        public const uint SHF_INFO_LINK = 64;
        
        /// <summary>
        /// Preserve order after combining
        /// </summary>
        public const uint SHF_LINK_ORDER = 128;
        
        /// <summary>
        /// Non-standard OS specific handling required
        /// </summary>
        public const uint SHF_OS_NONCONFORMING = 256;
        
        /// <summary>
        /// Section is member of a group.
        /// </summary>
        public const uint SHF_GROUP = 512;
        
        /// <summary>
        /// Section hold thread-local data.
        /// </summary>
        public const uint SHF_TLS = 1024;
        
        /// <summary>
        /// Section with compressed data.
        /// </summary>
        public const uint SHF_COMPRESSED = 2048;
        
        /// <summary>
        /// OS-specific.
        /// </summary>
        public const uint SHF_MASKOS = 267386880;
        
        /// <summary>
        /// Processor-specific
        /// </summary>
        public const uint SHF_MASKPROC = 0xf0000000;
        
        /// <summary>
        /// Special ordering requirement (Solaris).
        /// </summary>
        public const uint SHF_ORDERED = 1073741824;
        
        /// <summary>
        /// Section is excluded unless referenced or allocated (Solaris).
        /// </summary>
        public const uint SHF_EXCLUDE = (1U << 31);
        
        /// <summary>
        /// ZLIB/DEFLATE algorithm.
        /// </summary>
        public const int ELFCOMPRESS_ZLIB = 1;
        
        /// <summary>
        /// Start of OS-specific.
        /// </summary>
        public const int ELFCOMPRESS_LOOS = 0x60000000;
        
        /// <summary>
        /// End of OS-specific.
        /// </summary>
        public const int ELFCOMPRESS_HIOS = 0x6fffffff;
        
        /// <summary>
        /// Start of processor-specific.
        /// </summary>
        public const int ELFCOMPRESS_LOPROC = 0x70000000;
        
        /// <summary>
        /// End of processor-specific.
        /// </summary>
        public const int ELFCOMPRESS_HIPROC = 0x7fffffff;
        
        /// <summary>
        /// Symbol bound to self
        /// </summary>
        public const ushort SYMINFO_BT_SELF = 65535;
        
        /// <summary>
        /// Symbol bound to parent
        /// </summary>
        public const ushort SYMINFO_BT_PARENT = 65534;
        
        /// <summary>
        /// Beginning of reserved entries
        /// </summary>
        public const ushort SYMINFO_BT_LOWRESERVE = 65280;
        
        /// <summary>
        /// Direct bound symbol
        /// </summary>
        public const ushort SYMINFO_FLG_DIRECT = 1;
        
        /// <summary>
        /// Pass-thru symbol for translator
        /// </summary>
        public const ushort SYMINFO_FLG_PASSTHRU = 2;
        
        /// <summary>
        /// Symbol is a copy-reloc
        /// </summary>
        public const ushort SYMINFO_FLG_COPY = 4;
        
        /// <summary>
        /// Symbol bound to object to be lazy loaded
        /// </summary>
        public const ushort SYMINFO_FLG_LAZYLOAD = 8;
        
        public const ushort SYMINFO_NONE = 0;
        
        public const ushort SYMINFO_CURRENT = 1;
        
        public const ushort SYMINFO_NUM = 2;
        
        /// <summary>
        /// Local symbol
        /// </summary>
        public const byte STB_LOCAL = 0;
        
        /// <summary>
        /// Global symbol
        /// </summary>
        public const byte STB_GLOBAL = 1;
        
        /// <summary>
        /// Weak symbol
        /// </summary>
        public const byte STB_WEAK = 2;
        
        /// <summary>
        /// Number of defined types.
        /// </summary>
        public const byte STB_NUM = 3;
        
        /// <summary>
        /// Start of OS-specific
        /// </summary>
        public const byte STB_LOOS = 10;
        
        /// <summary>
        /// Unique symbol.
        /// </summary>
        public const byte STB_GNU_UNIQUE = 10;
        
        /// <summary>
        /// End of OS-specific
        /// </summary>
        public const byte STB_HIOS = 12;
        
        /// <summary>
        /// Start of processor-specific
        /// </summary>
        public const byte STB_LOPROC = 13;
        
        /// <summary>
        /// End of processor-specific
        /// </summary>
        public const byte STB_HIPROC = 15;
        
        /// <summary>
        /// Symbol type is unspecified
        /// </summary>
        public const byte STT_NOTYPE = 0;
        
        /// <summary>
        /// Symbol is a data object
        /// </summary>
        public const byte STT_OBJECT = 1;
        
        /// <summary>
        /// Symbol is a code object
        /// </summary>
        public const byte STT_FUNC = 2;
        
        /// <summary>
        /// Symbol associated with a section
        /// </summary>
        public const byte STT_SECTION = 3;
        
        /// <summary>
        /// Symbol's name is file name
        /// </summary>
        public const byte STT_FILE = 4;
        
        /// <summary>
        /// Symbol is a common data object
        /// </summary>
        public const byte STT_COMMON = 5;
        
        /// <summary>
        /// Symbol is thread-local data object
        /// </summary>
        public const byte STT_TLS = 6;
        
        /// <summary>
        /// Number of defined types.
        /// </summary>
        public const byte STT_NUM = 7;
        
        /// <summary>
        /// Start of OS-specific
        /// </summary>
        public const byte STT_LOOS = 10;
        
        /// <summary>
        /// Symbol is indirect code object
        /// </summary>
        public const byte STT_GNU_IFUNC = 10;
        
        /// <summary>
        /// End of OS-specific
        /// </summary>
        public const byte STT_HIOS = 12;
        
        /// <summary>
        /// Start of processor-specific
        /// </summary>
        public const byte STT_LOPROC = 13;
        
        /// <summary>
        /// End of processor-specific
        /// </summary>
        public const byte STT_HIPROC = 15;
        
        /// <summary>
        /// End of a chain.
        /// </summary>
        public const byte STN_UNDEF = 0;
        
        /// <summary>
        /// Default symbol visibility rules
        /// </summary>
        public const byte STV_DEFAULT = 0;
        
        /// <summary>
        /// Processor specific hidden class
        /// </summary>
        public const byte STV_INTERNAL = 1;
        
        /// <summary>
        /// Sym unavailable in other modules
        /// </summary>
        public const byte STV_HIDDEN = 2;
        
        /// <summary>
        /// Not preemptible, not exported
        /// </summary>
        public const byte STV_PROTECTED = 3;
        
        /// <summary>
        /// Program header table entry unused
        /// </summary>
        public const uint PT_NULL = 0;
        
        /// <summary>
        /// Loadable program segment
        /// </summary>
        public const uint PT_LOAD = 1;
        
        /// <summary>
        /// Dynamic linking information
        /// </summary>
        public const uint PT_DYNAMIC = 2;
        
        /// <summary>
        /// Program interpreter
        /// </summary>
        public const uint PT_INTERP = 3;
        
        /// <summary>
        /// Auxiliary information
        /// </summary>
        public const uint PT_NOTE = 4;
        
        /// <summary>
        /// Reserved
        /// </summary>
        public const uint PT_SHLIB = 5;
        
        /// <summary>
        /// Entry for header table itself
        /// </summary>
        public const uint PT_PHDR = 6;
        
        /// <summary>
        /// Thread-local storage segment
        /// </summary>
        public const uint PT_TLS = 7;
        
        /// <summary>
        /// Number of defined types
        /// </summary>
        public const uint PT_NUM = 8;
        
        /// <summary>
        /// Start of OS-specific
        /// </summary>
        public const uint PT_LOOS = 1610612736;
        
        /// <summary>
        /// GCC .eh_frame_hdr segment
        /// </summary>
        public const uint PT_GNU_EH_FRAME = 1685382480;
        
        /// <summary>
        /// Indicates stack executability
        /// </summary>
        public const uint PT_GNU_STACK = 1685382481;
        
        /// <summary>
        /// Read-only after relocation
        /// </summary>
        public const uint PT_GNU_RELRO = 1685382482;
        
        public const uint PT_LOSUNW = 1879048186;
        
        /// <summary>
        /// Sun Specific segment
        /// </summary>
        public const uint PT_SUNWBSS = 1879048186;
        
        /// <summary>
        /// Stack segment
        /// </summary>
        public const uint PT_SUNWSTACK = 1879048187;
        
        public const uint PT_HISUNW = 1879048191;
        
        /// <summary>
        /// End of OS-specific
        /// </summary>
        public const uint PT_HIOS = 1879048191;
        
        /// <summary>
        /// Start of processor-specific
        /// </summary>
        public const uint PT_LOPROC = 1879048192;
        
        /// <summary>
        /// End of processor-specific
        /// </summary>
        public const uint PT_HIPROC = 2147483647;
        
        /// <summary>
        /// Segment is executable
        /// </summary>
        public const uint PF_X = 1;
        
        /// <summary>
        /// Segment is writable
        /// </summary>
        public const uint PF_W = 2;
        
        /// <summary>
        /// Segment is readable
        /// </summary>
        public const uint PF_R = 4;
        
        /// <summary>
        /// OS-specific
        /// </summary>
        public const uint PF_MASKOS = 267386880;
        
        /// <summary>
        /// Processor-specific
        /// </summary>
        public const uint PF_MASKPROC = 0xf0000000;
        
        /// <summary>
        /// Contains copy of prstatus struct
        /// </summary>
        public const uint NT_PRSTATUS = 1;
        
        /// <summary>
        /// Contains copy of fpregset struct
        /// </summary>
        public const uint NT_FPREGSET = 2;
        
        /// <summary>
        /// Contains copy of prpsinfo struct
        /// </summary>
        public const uint NT_PRPSINFO = 3;
        
        /// <summary>
        /// Contains copy of prxregset struct
        /// </summary>
        public const uint NT_PRXREG = 4;
        
        /// <summary>
        /// Contains copy of task structure
        /// </summary>
        public const uint NT_TASKSTRUCT = 4;
        
        /// <summary>
        /// String from sysinfo(SI_PLATFORM)
        /// </summary>
        public const uint NT_PLATFORM = 5;
        
        /// <summary>
        /// Contains copy of auxv array
        /// </summary>
        public const uint NT_AUXV = 6;
        
        /// <summary>
        /// Contains copy of gwindows struct
        /// </summary>
        public const uint NT_GWINDOWS = 7;
        
        /// <summary>
        /// Contains copy of asrset struct
        /// </summary>
        public const uint NT_ASRS = 8;
        
        /// <summary>
        /// Contains copy of pstatus struct
        /// </summary>
        public const uint NT_PSTATUS = 10;
        
        /// <summary>
        /// Contains copy of psinfo struct
        /// </summary>
        public const uint NT_PSINFO = 13;
        
        /// <summary>
        /// Contains copy of prcred struct
        /// </summary>
        public const uint NT_PRCRED = 14;
        
        /// <summary>
        /// Contains copy of utsname struct
        /// </summary>
        public const uint NT_UTSNAME = 15;
        
        /// <summary>
        /// Contains copy of lwpstatus struct
        /// </summary>
        public const uint NT_LWPSTATUS = 16;
        
        /// <summary>
        /// Contains copy of lwpinfo struct
        /// </summary>
        public const uint NT_LWPSINFO = 17;
        
        /// <summary>
        /// Contains copy of fprxregset struct
        /// </summary>
        public const uint NT_PRFPXREG = 20;
        
        /// <summary>
        /// Contains copy of siginfo_t, size might increase
        /// </summary>
        public const uint NT_SIGINFO = 1397311305;
        
        /// <summary>
        /// Contains information about mapped files
        /// </summary>
        public const uint NT_FILE = 1179208773;
        
        /// <summary>
        /// Contains copy of user_fxsr_struct
        /// </summary>
        public const uint NT_PRXFPREG = 1189489535;
        
        /// <summary>
        /// PowerPC Altivec/VMX registers
        /// </summary>
        public const uint NT_PPC_VMX = 256;
        
        /// <summary>
        /// PowerPC SPE/EVR registers
        /// </summary>
        public const uint NT_PPC_SPE = 257;
        
        /// <summary>
        /// PowerPC VSX registers
        /// </summary>
        public const uint NT_PPC_VSX = 258;
        
        /// <summary>
        /// i386 TLS slots (struct user_desc)
        /// </summary>
        public const uint NT_386_TLS = 512;
        
        /// <summary>
        /// x86 io permission bitmap (1=deny)
        /// </summary>
        public const uint NT_386_IOPERM = 513;
        
        /// <summary>
        /// x86 extended state using xsave
        /// </summary>
        public const uint NT_X86_XSTATE = 514;
        
        /// <summary>
        /// s390 upper register halves
        /// </summary>
        public const uint NT_S390_HIGH_GPRS = 768;
        
        /// <summary>
        /// s390 timer register
        /// </summary>
        public const uint NT_S390_TIMER = 769;
        
        /// <summary>
        /// s390 TOD clock comparator register
        /// </summary>
        public const uint NT_S390_TODCMP = 770;
        
        /// <summary>
        /// s390 TOD programmable register
        /// </summary>
        public const uint NT_S390_TODPREG = 771;
        
        /// <summary>
        /// s390 control registers
        /// </summary>
        public const uint NT_S390_CTRS = 772;
        
        /// <summary>
        /// s390 prefix register
        /// </summary>
        public const uint NT_S390_PREFIX = 773;
        
        /// <summary>
        /// s390 breaking event address
        /// </summary>
        public const uint NT_S390_LAST_BREAK = 774;
        
        /// <summary>
        /// s390 system call restart data
        /// </summary>
        public const uint NT_S390_SYSTEM_CALL = 775;
        
        /// <summary>
        /// s390 transaction diagnostic block
        /// </summary>
        public const uint NT_S390_TDB = 776;
        
        /// <summary>
        /// ARM VFP/NEON registers
        /// </summary>
        public const uint NT_ARM_VFP = 1024;
        
        /// <summary>
        /// ARM TLS register
        /// </summary>
        public const uint NT_ARM_TLS = 1025;
        
        /// <summary>
        /// ARM hardware breakpoint registers
        /// </summary>
        public const uint NT_ARM_HW_BREAK = 1026;
        
        /// <summary>
        /// ARM hardware watchpoint registers
        /// </summary>
        public const uint NT_ARM_HW_WATCH = 1027;
        
        /// <summary>
        /// Contains a version string.
        /// </summary>
        public const uint NT_VERSION = 1;
        
        /// <summary>
        /// Marks end of dynamic section
        /// </summary>
        public const int DT_NULL = 0;
        
        /// <summary>
        /// Name of needed library
        /// </summary>
        public const int DT_NEEDED = 1;
        
        /// <summary>
        /// Size in bytes of PLT relocs
        /// </summary>
        public const int DT_PLTRELSZ = 2;
        
        /// <summary>
        /// Processor defined value
        /// </summary>
        public const int DT_PLTGOT = 3;
        
        /// <summary>
        /// Address of symbol hash table
        /// </summary>
        public const int DT_HASH = 4;
        
        /// <summary>
        /// Address of string table
        /// </summary>
        public const int DT_STRTAB = 5;
        
        /// <summary>
        /// Address of symbol table
        /// </summary>
        public const int DT_SYMTAB = 6;
        
        /// <summary>
        /// Address of Rela relocs
        /// </summary>
        public const int DT_RELA = 7;
        
        /// <summary>
        /// Total size of Rela relocs
        /// </summary>
        public const int DT_RELASZ = 8;
        
        /// <summary>
        /// Size of one Rela reloc
        /// </summary>
        public const int DT_RELAENT = 9;
        
        /// <summary>
        /// Size of string table
        /// </summary>
        public const int DT_STRSZ = 10;
        
        /// <summary>
        /// Size of one symbol table entry
        /// </summary>
        public const int DT_SYMENT = 11;
        
        /// <summary>
        /// Address of init function
        /// </summary>
        public const int DT_INIT = 12;
        
        /// <summary>
        /// Address of termination function
        /// </summary>
        public const int DT_FINI = 13;
        
        /// <summary>
        /// Name of shared object
        /// </summary>
        public const int DT_SONAME = 14;
        
        /// <summary>
        /// Library search path (deprecated)
        /// </summary>
        public const int DT_RPATH = 15;
        
        /// <summary>
        /// Start symbol search here
        /// </summary>
        public const int DT_SYMBOLIC = 16;
        
        /// <summary>
        /// Address of Rel relocs
        /// </summary>
        public const int DT_REL = 17;
        
        /// <summary>
        /// Total size of Rel relocs
        /// </summary>
        public const int DT_RELSZ = 18;
        
        /// <summary>
        /// Size of one Rel reloc
        /// </summary>
        public const int DT_RELENT = 19;
        
        /// <summary>
        /// Type of reloc in PLT
        /// </summary>
        public const int DT_PLTREL = 20;
        
        /// <summary>
        /// For debugging; unspecified
        /// </summary>
        public const int DT_DEBUG = 21;
        
        /// <summary>
        /// Reloc might modify .text
        /// </summary>
        public const int DT_TEXTREL = 22;
        
        /// <summary>
        /// Address of PLT relocs
        /// </summary>
        public const int DT_JMPREL = 23;
        
        /// <summary>
        /// Process relocations of object
        /// </summary>
        public const int DT_BIND_NOW = 24;
        
        /// <summary>
        /// Array with addresses of init fct
        /// </summary>
        public const int DT_INIT_ARRAY = 25;
        
        /// <summary>
        /// Array with addresses of fini fct
        /// </summary>
        public const int DT_FINI_ARRAY = 26;
        
        /// <summary>
        /// Size in bytes of DT_INIT_ARRAY
        /// </summary>
        public const int DT_INIT_ARRAYSZ = 27;
        
        /// <summary>
        /// Size in bytes of DT_FINI_ARRAY
        /// </summary>
        public const int DT_FINI_ARRAYSZ = 28;
        
        /// <summary>
        /// Library search path
        /// </summary>
        public const int DT_RUNPATH = 29;
        
        /// <summary>
        /// Flags for the object being loaded
        /// </summary>
        public const int DT_FLAGS = 30;
        
        /// <summary>
        /// Start of encoded range
        /// </summary>
        public const int DT_ENCODING = 32;
        
        /// <summary>
        /// Array with addresses of preinit fct
        /// </summary>
        public const int DT_PREINIT_ARRAY = 32;
        
        /// <summary>
        /// size in bytes of DT_PREINIT_ARRAY
        /// </summary>
        public const int DT_PREINIT_ARRAYSZ = 33;
        
        /// <summary>
        /// Number used
        /// </summary>
        public const int DT_NUM = 34;
        
        /// <summary>
        /// Start of OS-specific
        /// </summary>
        public const int DT_LOOS = 0x6000000d;
        
        /// <summary>
        /// End of OS-specific
        /// </summary>
        public const int DT_HIOS = 0x6ffff000;
        
        /// <summary>
        /// Start of processor-specific
        /// </summary>
        public const int DT_LOPROC = 0x70000000;
        
        /// <summary>
        /// End of processor-specific
        /// </summary>
        public const int DT_HIPROC = 0x7fffffff;
        
        /// <summary>
        /// Most used by any processor
        /// </summary>
        public const int DT_PROCNUM = 0x36;
        
        public const int DT_VALRNGLO = 0x6ffffd00;
        
        /// <summary>
        /// Prelinking timestamp
        /// </summary>
        public const int DT_GNU_PRELINKED = 0x6ffffdf5;
        
        /// <summary>
        /// Size of conflict section
        /// </summary>
        public const int DT_GNU_CONFLICTSZ = 0x6ffffdf6;
        
        /// <summary>
        /// Size of library list
        /// </summary>
        public const int DT_GNU_LIBLISTSZ = 0x6ffffdf7;
        
        public const int DT_CHECKSUM = 0x6ffffdf8;
        
        public const int DT_PLTPADSZ = 0x6ffffdf9;
        
        public const int DT_MOVEENT = 0x6ffffdfa;
        
        public const int DT_MOVESZ = 0x6ffffdfb;
        
        /// <summary>
        /// Feature selection (DTF_*).
        /// </summary>
        public const int DT_FEATURE_1 = 0x6ffffdfc;
        
        /// <summary>
        /// Flags for DT_* entries, effecting the following DT_* entry.
        /// </summary>
        public const int DT_POSFLAG_1 = 0x6ffffdfd;
        
        /// <summary>
        /// Size of syminfo table (in bytes)
        /// </summary>
        public const int DT_SYMINSZ = 0x6ffffdfe;
        
        /// <summary>
        /// Entry size of syminfo
        /// </summary>
        public const int DT_SYMINENT = 0x6ffffdff;
        
        public const int DT_VALRNGHI = 0x6ffffdff;
        
        public const int DT_VALNUM = 12;
        
        public const int DT_ADDRRNGLO = 0x6ffffe00;
        
        /// <summary>
        /// GNU-style hash table.
        /// </summary>
        public const int DT_GNU_HASH = 0x6ffffef5;
        
        public const int DT_TLSDESC_PLT = 0x6ffffef6;
        
        public const int DT_TLSDESC_GOT = 0x6ffffef7;
        
        /// <summary>
        /// Start of conflict section
        /// </summary>
        public const int DT_GNU_CONFLICT = 0x6ffffef8;
        
        /// <summary>
        /// Library list
        /// </summary>
        public const int DT_GNU_LIBLIST = 0x6ffffef9;
        
        /// <summary>
        /// Configuration information.
        /// </summary>
        public const int DT_CONFIG = 0x6ffffefa;
        
        /// <summary>
        /// Dependency auditing.
        /// </summary>
        public const int DT_DEPAUDIT = 0x6ffffefb;
        
        /// <summary>
        /// Object auditing.
        /// </summary>
        public const int DT_AUDIT = 0x6ffffefc;
        
        /// <summary>
        /// PLT padding.
        /// </summary>
        public const int DT_PLTPAD = 0x6ffffefd;
        
        /// <summary>
        /// Move table.
        /// </summary>
        public const int DT_MOVETAB = 0x6ffffefe;
        
        /// <summary>
        /// Syminfo table.
        /// </summary>
        public const int DT_SYMINFO = 0x6ffffeff;
        
        public const int DT_ADDRRNGHI = 0x6ffffeff;
        
        public const int DT_ADDRNUM = 11;
        
        public const int DT_VERSYM = 0x6ffffff0;
        
        public const int DT_RELACOUNT = 0x6ffffff9;
        
        public const int DT_RELCOUNT = 0x6ffffffa;
        
        /// <summary>
        /// State flags, see DF_1_* below.
        /// </summary>
        public const int DT_FLAGS_1 = 0x6ffffffb;
        
        /// <summary>
        /// Address of version definition table
        /// </summary>
        public const int DT_VERDEF = 0x6ffffffc;
        
        /// <summary>
        /// Number of version definitions
        /// </summary>
        public const int DT_VERDEFNUM = 0x6ffffffd;
        
        /// <summary>
        /// Address of table with needed versions
        /// </summary>
        public const int DT_VERNEED = 0x6ffffffe;
        
        /// <summary>
        /// Number of needed versions
        /// </summary>
        public const int DT_VERNEEDNUM = 0x6fffffff;
        
        public const int DT_VERSIONTAGNUM = 16;
        
        /// <summary>
        /// Shared object to load before self
        /// </summary>
        public const int DT_AUXILIARY = 0x7ffffffd;
        
        /// <summary>
        /// Shared object to get values from
        /// </summary>
        public const int DT_FILTER = 0x7fffffff;
        
        public const int DT_EXTRANUM = 3;
        
        /// <summary>
        /// Object may use DF_ORIGIN
        /// </summary>
        public const uint DF_ORIGIN = 1;
        
        /// <summary>
        /// Symbol resolutions starts here
        /// </summary>
        public const uint DF_SYMBOLIC = 2;
        
        /// <summary>
        /// Object contains text relocations
        /// </summary>
        public const uint DF_TEXTREL = 4;
        
        /// <summary>
        /// No lazy binding for this object
        /// </summary>
        public const uint DF_BIND_NOW = 8;
        
        /// <summary>
        /// Module uses the static TLS model
        /// </summary>
        public const uint DF_STATIC_TLS = 16;
        
        /// <summary>
        /// Set RTLD_NOW for this object.
        /// </summary>
        public const uint DF_1_NOW = 1;
        
        /// <summary>
        /// Set RTLD_GLOBAL for this object.
        /// </summary>
        public const uint DF_1_GLOBAL = 2;
        
        /// <summary>
        /// Set RTLD_GROUP for this object.
        /// </summary>
        public const uint DF_1_GROUP = 4;
        
        /// <summary>
        /// Set RTLD_NODELETE for this object.
        /// </summary>
        public const uint DF_1_NODELETE = 8;
        
        /// <summary>
        /// Trigger filtee loading at runtime.
        /// </summary>
        public const uint DF_1_LOADFLTR = 16;
        
        /// <summary>
        /// Set RTLD_INITFIRST for this object
        /// </summary>
        public const uint DF_1_INITFIRST = 32;
        
        /// <summary>
        /// Set RTLD_NOOPEN for this object.
        /// </summary>
        public const uint DF_1_NOOPEN = 64;
        
        /// <summary>
        /// $ORIGIN must be handled.
        /// </summary>
        public const uint DF_1_ORIGIN = 128;
        
        /// <summary>
        /// Direct binding enabled.
        /// </summary>
        public const uint DF_1_DIRECT = 256;
        
        public const uint DF_1_TRANS = 512;
        
        /// <summary>
        /// Object is used to interpose.
        /// </summary>
        public const uint DF_1_INTERPOSE = 1024;
        
        /// <summary>
        /// Ignore default lib search path.
        /// </summary>
        public const uint DF_1_NODEFLIB = 2048;
        
        /// <summary>
        /// Object can't be dldump'ed.
        /// </summary>
        public const uint DF_1_NODUMP = 4096;
        
        /// <summary>
        /// Configuration alternative created.
        /// </summary>
        public const uint DF_1_CONFALT = 8192;
        
        /// <summary>
        /// Filtee terminates filters search.
        /// </summary>
        public const uint DF_1_ENDFILTEE = 16384;
        
        /// <summary>
        /// Disp reloc applied at build time.
        /// </summary>
        public const uint DF_1_DISPRELDNE = 32768;
        
        /// <summary>
        /// Disp reloc applied at run-time.
        /// </summary>
        public const uint DF_1_DISPRELPND = 65536;
        
        /// <summary>
        /// Object has no-direct binding.
        /// </summary>
        public const uint DF_1_NODIRECT = 131072;
        
        public const uint DF_1_IGNMULDEF = 262144;
        
        public const uint DF_1_NOKSYMS = 524288;
        
        public const uint DF_1_NOHDR = 1048576;
        
        /// <summary>
        /// Object is modified after built.
        /// </summary>
        public const uint DF_1_EDITED = 2097152;
        
        public const uint DF_1_NORELOC = 4194304;
        
        /// <summary>
        /// Object has individual interposers.
        /// </summary>
        public const uint DF_1_SYMINTPOSE = 8388608;
        
        /// <summary>
        /// Global auditing required.
        /// </summary>
        public const uint DF_1_GLOBAUDIT = 16777216;
        
        /// <summary>
        /// Singleton symbols are used.
        /// </summary>
        public const uint DF_1_SINGLETON = 33554432;
        
        public const uint DTF_1_PARINIT = 1;
        
        public const uint DTF_1_CONFEXP = 2;
        
        /// <summary>
        /// Lazyload following object.
        /// </summary>
        public const uint DF_P1_LAZYLOAD = 1;
        
        /// <summary>
        /// Symbols from next object are not generally available.
        /// </summary>
        public const uint DF_P1_GROUPPERM = 2;
        
        /// <summary>
        /// No version
        /// </summary>
        public const ushort VER_DEF_NONE = 0;
        
        /// <summary>
        /// Current version
        /// </summary>
        public const ushort VER_DEF_CURRENT = 1;
        
        /// <summary>
        /// Given version number
        /// </summary>
        public const ushort VER_DEF_NUM = 2;
        
        /// <summary>
        /// Version definition of file itself
        /// </summary>
        public const ushort VER_FLG_BASE = 1;
        
        /// <summary>
        /// Weak version identifier
        /// </summary>
        public const ushort VER_FLG_WEAK = 2;
        
        /// <summary>
        /// Symbol is local.
        /// </summary>
        public const ushort VER_NDX_LOCAL = 0;
        
        /// <summary>
        /// Symbol is global.
        /// </summary>
        public const ushort VER_NDX_GLOBAL = 1;
        
        /// <summary>
        /// Beginning of reserved entries.
        /// </summary>
        public const ushort VER_NDX_LORESERVE = 65280;
        
        /// <summary>
        /// Symbol is to be eliminated.
        /// </summary>
        public const ushort VER_NDX_ELIMINATE = 65281;
        
        /// <summary>
        /// No version
        /// </summary>
        public const ushort VER_NEED_NONE = 0;
        
        /// <summary>
        /// Current version
        /// </summary>
        public const ushort VER_NEED_CURRENT = 1;
        
        /// <summary>
        /// Given version number
        /// </summary>
        public const ushort VER_NEED_NUM = 2;
        
        public const uint NT_GNU_ABI_TAG = 1;
        
        public const uint NT_GNU_HWCAP = 2;
        
        public const uint NT_GNU_BUILD_ID = 3;
        
        public const uint NT_GNU_GOLD_VERSION = 4;
        
        public const uint EF_CPU32 = 8454144;
        
        /// <summary>
        /// No reloc
        /// </summary>
        public const uint R_386_NONE = 0;
        
        /// <summary>
        /// Direct 32 bit
        /// </summary>
        public const uint R_386_32 = 1;
        
        /// <summary>
        /// PC relative 32 bit
        /// </summary>
        public const uint R_386_PC32 = 2;
        
        /// <summary>
        /// 32 bit GOT entry
        /// </summary>
        public const uint R_386_GOT32 = 3;
        
        /// <summary>
        /// 32 bit PLT address
        /// </summary>
        public const uint R_386_PLT32 = 4;
        
        /// <summary>
        /// Copy symbol at runtime
        /// </summary>
        public const uint R_386_COPY = 5;
        
        /// <summary>
        /// Create GOT entry
        /// </summary>
        public const uint R_386_GLOB_DAT = 6;
        
        /// <summary>
        /// Create PLT entry
        /// </summary>
        public const uint R_386_JMP_SLOT = 7;
        
        /// <summary>
        /// Adjust by program base
        /// </summary>
        public const uint R_386_RELATIVE = 8;
        
        /// <summary>
        /// 32 bit offset to GOT
        /// </summary>
        public const uint R_386_GOTOFF = 9;
        
        /// <summary>
        /// 32 bit PC relative offset to GOT
        /// </summary>
        public const uint R_386_GOTPC = 10;
        
        public const uint R_386_32PLT = 11;
        
        /// <summary>
        /// Offset in static TLS block
        /// </summary>
        public const uint R_386_TLS_TPOFF = 14;
        
        /// <summary>
        /// Address of GOT entry for static TLS block offset
        /// </summary>
        public const uint R_386_TLS_IE = 15;
        
        /// <summary>
        /// GOT entry for static TLS block offset
        /// </summary>
        public const uint R_386_TLS_GOTIE = 16;
        
        /// <summary>
        /// Offset relative to static TLS block
        /// </summary>
        public const uint R_386_TLS_LE = 17;
        
        /// <summary>
        /// Direct 32 bit for GNU version of general dynamic thread local data
        /// </summary>
        public const uint R_386_TLS_GD = 18;
        
        /// <summary>
        /// Direct 32 bit for GNU version of local dynamic thread local data in LE code
        /// </summary>
        public const uint R_386_TLS_LDM = 19;
        
        public const uint R_386_16 = 20;
        
        public const uint R_386_PC16 = 21;
        
        public const uint R_386_8 = 22;
        
        public const uint R_386_PC8 = 23;
        
        /// <summary>
        /// Direct 32 bit for general dynamic
        /// thread local data
        /// </summary>
        public const uint R_386_TLS_GD_32 = 24;
        
        /// <summary>
        /// Tag for pushl in GD TLS code
        /// </summary>
        public const uint R_386_TLS_GD_PUSH = 25;
        
        /// <summary>
        /// Relocation for call to
        /// __tls_get_addr()
        /// </summary>
        public const uint R_386_TLS_GD_CALL = 26;
        
        /// <summary>
        /// Tag for popl in GD TLS code
        /// </summary>
        public const uint R_386_TLS_GD_POP = 27;
        
        /// <summary>
        /// Direct 32 bit for local dynamic
        /// thread local data in LE code
        /// </summary>
        public const uint R_386_TLS_LDM_32 = 28;
        
        /// <summary>
        /// Tag for pushl in LDM TLS code
        /// </summary>
        public const uint R_386_TLS_LDM_PUSH = 29;
        
        /// <summary>
        /// Relocation for call to
        /// __tls_get_addr() in LDM code
        /// </summary>
        public const uint R_386_TLS_LDM_CALL = 30;
        
        /// <summary>
        /// Tag for popl in LDM TLS code
        /// </summary>
        public const uint R_386_TLS_LDM_POP = 31;
        
        /// <summary>
        /// Offset relative to TLS block
        /// </summary>
        public const uint R_386_TLS_LDO_32 = 32;
        
        /// <summary>
        /// GOT entry for negated static TLS
        /// block offset
        /// </summary>
        public const uint R_386_TLS_IE_32 = 33;
        
        /// <summary>
        /// Negated offset relative to static
        /// TLS block
        /// </summary>
        public const uint R_386_TLS_LE_32 = 34;
        
        /// <summary>
        /// ID of module containing symbol
        /// </summary>
        public const uint R_386_TLS_DTPMOD32 = 35;
        
        /// <summary>
        /// Offset in TLS block
        /// </summary>
        public const uint R_386_TLS_DTPOFF32 = 36;
        
        /// <summary>
        /// Negated offset in static TLS block
        /// </summary>
        public const uint R_386_TLS_TPOFF32 = 37;
        
        /// <summary>
        /// 32-bit symbol size
        /// </summary>
        public const uint R_386_SIZE32 = 38;
        
        /// <summary>
        /// GOT offset for TLS descriptor.
        /// </summary>
        public const uint R_386_TLS_GOTDESC = 39;
        
        /// <summary>
        /// Marker of call through TLS
        /// descriptor for
        /// relaxation.
        /// </summary>
        public const uint R_386_TLS_DESC_CALL = 40;
        
        /// <summary>
        /// TLS descriptor containing
        /// pointer to code and to
        /// argument, returning the TLS
        /// offset for the symbol.
        /// </summary>
        public const uint R_386_TLS_DESC = 41;
        
        /// <summary>
        /// Adjust indirectly by program base
        /// </summary>
        public const uint R_386_IRELATIVE = 42;
        
        public const uint R_386_NUM = 43;
        
        /// <summary>
        /// Global register reserved to app.
        /// </summary>
        public const byte STT_SPARC_REGISTER = 13;
        
        public const uint EF_SPARCV9_MM = 3;
        
        public const uint EF_SPARCV9_TSO = 0;
        
        public const uint EF_SPARCV9_PSO = 1;
        
        public const uint EF_SPARCV9_RMO = 2;
        
        /// <summary>
        /// little endian data
        /// </summary>
        public const uint EF_SPARC_LEDATA = 8388608;
        
        public const uint EF_SPARC_EXT_MASK = 16776960;
        
        /// <summary>
        /// generic V8+ features
        /// </summary>
        public const uint EF_SPARC_32PLUS = 256;
        
        /// <summary>
        /// Sun UltraSPARC1 extensions
        /// </summary>
        public const uint EF_SPARC_SUN_US1 = 512;
        
        /// <summary>
        /// HAL R1 extensions
        /// </summary>
        public const uint EF_SPARC_HAL_R1 = 1024;
        
        /// <summary>
        /// Sun UltraSPARCIII extensions
        /// </summary>
        public const uint EF_SPARC_SUN_US3 = 2048;
        
        public const int DT_SPARC_REGISTER = 0x70000001;
        
        public const int DT_SPARC_NUM = 2;
        
        /// <summary>
        /// A .noreorder directive was used.
        /// </summary>
        public const uint EF_MIPS_NOREORDER = 1;
        
        /// <summary>
        /// Contains PIC code.
        /// </summary>
        public const uint EF_MIPS_PIC = 2;
        
        /// <summary>
        /// Uses PIC calling sequence.
        /// </summary>
        public const uint EF_MIPS_CPIC = 4;
        
        public const uint EF_MIPS_XGOT = 8;
        
        public const uint EF_MIPS_64BIT_WHIRL = 16;
        
        public const uint EF_MIPS_ABI2 = 32;
        
        public const uint EF_MIPS_ABI_ON32 = 64;
        
        /// <summary>
        /// Uses FP64 (12 callee-saved).
        /// </summary>
        public const uint EF_MIPS_FP64 = 512;
        
        /// <summary>
        /// Uses IEEE 754-2008 NaN encoding.
        /// </summary>
        public const uint EF_MIPS_NAN2008 = 1024;
        
        /// <summary>
        /// MIPS architecture level.
        /// </summary>
        public const uint EF_MIPS_ARCH = 0xf0000000;
        
        /// <summary>
        /// -mips1 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_1 = 0;
        
        /// <summary>
        /// -mips2 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_2 = 268435456;
        
        /// <summary>
        /// -mips3 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_3 = 536870912;
        
        /// <summary>
        /// -mips4 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_4 = 805306368;
        
        /// <summary>
        /// -mips5 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_5 = 1073741824;
        
        /// <summary>
        /// MIPS32 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_32 = 1342177280;
        
        /// <summary>
        /// MIPS64 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_64 = 1610612736;
        
        /// <summary>
        /// MIPS32r2 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_32R2 = 1879048192;
        
        /// <summary>
        /// MIPS64r2 code.
        /// </summary>
        public const uint EF_MIPS_ARCH_64R2 = 0x80000000;
        
        /// <summary>
        /// Allocated common symbols.
        /// </summary>
        public const uint SHN_MIPS_ACOMMON = 65280;
        
        /// <summary>
        /// Allocated test symbols.
        /// </summary>
        public const uint SHN_MIPS_TEXT = 65281;
        
        /// <summary>
        /// Allocated data symbols.
        /// </summary>
        public const uint SHN_MIPS_DATA = 65282;
        
        /// <summary>
        /// Small common symbols.
        /// </summary>
        public const uint SHN_MIPS_SCOMMON = 65283;
        
        /// <summary>
        /// Small undefined symbols.
        /// </summary>
        public const uint SHN_MIPS_SUNDEFINED = 65284;
        
        /// <summary>
        /// Shared objects used in link.
        /// </summary>
        public const uint SHT_MIPS_LIBLIST = 1879048192;
        
        public const uint SHT_MIPS_MSYM = 1879048193;
        
        /// <summary>
        /// Conflicting symbols.
        /// </summary>
        public const uint SHT_MIPS_CONFLICT = 1879048194;
        
        /// <summary>
        /// Global data area sizes.
        /// </summary>
        public const uint SHT_MIPS_GPTAB = 1879048195;
        
        /// <summary>
        /// Reserved for SGI/MIPS compilers
        /// </summary>
        public const uint SHT_MIPS_UCODE = 1879048196;
        
        /// <summary>
        /// MIPS ECOFF debugging info.
        /// </summary>
        public const uint SHT_MIPS_DEBUG = 1879048197;
        
        /// <summary>
        /// Register usage information.
        /// </summary>
        public const uint SHT_MIPS_REGINFO = 1879048198;
        
        public const uint SHT_MIPS_PACKAGE = 1879048199;
        
        public const uint SHT_MIPS_PACKSYM = 1879048200;
        
        public const uint SHT_MIPS_RELD = 1879048201;
        
        public const uint SHT_MIPS_IFACE = 1879048203;
        
        public const uint SHT_MIPS_CONTENT = 1879048204;
        
        /// <summary>
        /// Miscellaneous options.
        /// </summary>
        public const uint SHT_MIPS_OPTIONS = 1879048205;
        
        public const uint SHT_MIPS_SHDR = 1879048208;
        
        public const uint SHT_MIPS_FDESC = 1879048209;
        
        public const uint SHT_MIPS_EXTSYM = 1879048210;
        
        public const uint SHT_MIPS_DENSE = 1879048211;
        
        public const uint SHT_MIPS_PDESC = 1879048212;
        
        public const uint SHT_MIPS_LOCSYM = 1879048213;
        
        public const uint SHT_MIPS_AUXSYM = 1879048214;
        
        public const uint SHT_MIPS_OPTSYM = 1879048215;
        
        public const uint SHT_MIPS_LOCSTR = 1879048216;
        
        public const uint SHT_MIPS_LINE = 1879048217;
        
        public const uint SHT_MIPS_RFDESC = 1879048218;
        
        public const uint SHT_MIPS_DELTASYM = 1879048219;
        
        public const uint SHT_MIPS_DELTAINST = 1879048220;
        
        public const uint SHT_MIPS_DELTACLASS = 1879048221;
        
        /// <summary>
        /// DWARF debugging information.
        /// </summary>
        public const uint SHT_MIPS_DWARF = 1879048222;
        
        public const uint SHT_MIPS_DELTADECL = 1879048223;
        
        public const uint SHT_MIPS_SYMBOL_LIB = 1879048224;
        
        /// <summary>
        /// Event section.
        /// </summary>
        public const uint SHT_MIPS_EVENTS = 1879048225;
        
        public const uint SHT_MIPS_TRANSLATE = 1879048226;
        
        public const uint SHT_MIPS_PIXIE = 1879048227;
        
        public const uint SHT_MIPS_XLATE = 1879048228;
        
        public const uint SHT_MIPS_XLATE_DEBUG = 1879048229;
        
        public const uint SHT_MIPS_WHIRL = 1879048230;
        
        public const uint SHT_MIPS_EH_REGION = 1879048231;
        
        public const uint SHT_MIPS_XLATE_OLD = 1879048232;
        
        public const uint SHT_MIPS_PDR_EXCEPTION = 1879048233;
        
        /// <summary>
        /// Must be in global data area.
        /// </summary>
        public const uint SHF_MIPS_GPREL = 268435456;
        
        public const uint SHF_MIPS_MERGE = 536870912;
        
        public const uint SHF_MIPS_ADDR = 1073741824;
        
        public const uint SHF_MIPS_STRINGS = 0x80000000;
        
        public const uint SHF_MIPS_NOSTRIP = 134217728;
        
        public const uint SHF_MIPS_LOCAL = 67108864;
        
        public const uint SHF_MIPS_NAMES = 33554432;
        
        public const uint SHF_MIPS_NODUPE = 16777216;
        
        public const byte STB_MIPS_SPLIT_COMMON = 13;
        
        /// <summary>
        /// Register usage information.
        /// </summary>
        public const uint PT_MIPS_REGINFO = 1879048192;
        
        /// <summary>
        /// Runtime procedure table.
        /// </summary>
        public const uint PT_MIPS_RTPROC = 1879048193;
        
        public const uint PT_MIPS_OPTIONS = 1879048194;
        
        /// <summary>
        /// FP mode requirement.
        /// </summary>
        public const uint PT_MIPS_ABIFLAGS = 1879048195;
        
        public const uint PF_MIPS_LOCAL = 268435456;
        
        /// <summary>
        /// Runtime linker interface version
        /// </summary>
        public const int DT_MIPS_RLD_VERSION = 0x70000001;
        
        /// <summary>
        /// Timestamp
        /// </summary>
        public const int DT_MIPS_TIME_STAMP = 0x70000002;
        
        /// <summary>
        /// Checksum
        /// </summary>
        public const int DT_MIPS_ICHECKSUM = 0x70000003;
        
        /// <summary>
        /// Version string (string tbl index)
        /// </summary>
        public const int DT_MIPS_IVERSION = 0x70000004;
        
        /// <summary>
        /// Flags
        /// </summary>
        public const int DT_MIPS_FLAGS = 0x70000005;
        
        /// <summary>
        /// Base address
        /// </summary>
        public const int DT_MIPS_BASE_ADDRESS = 0x70000006;
        
        public const int DT_MIPS_MSYM = 0x70000007;
        
        /// <summary>
        /// Address of CONFLICT section
        /// </summary>
        public const int DT_MIPS_CONFLICT = 0x70000008;
        
        /// <summary>
        /// Address of LIBLIST section
        /// </summary>
        public const int DT_MIPS_LIBLIST = 0x70000009;
        
        /// <summary>
        /// Number of local GOT entries
        /// </summary>
        public const int DT_MIPS_LOCAL_GOTNO = 0x7000000a;
        
        /// <summary>
        /// Number of CONFLICT entries
        /// </summary>
        public const int DT_MIPS_CONFLICTNO = 0x7000000b;
        
        /// <summary>
        /// Number of LIBLIST entries
        /// </summary>
        public const int DT_MIPS_LIBLISTNO = 0x70000010;
        
        /// <summary>
        /// Number of DYNSYM entries
        /// </summary>
        public const int DT_MIPS_SYMTABNO = 0x70000011;
        
        /// <summary>
        /// First external DYNSYM
        /// </summary>
        public const int DT_MIPS_UNREFEXTNO = 0x70000012;
        
        /// <summary>
        /// First GOT entry in DYNSYM
        /// </summary>
        public const int DT_MIPS_GOTSYM = 0x70000013;
        
        /// <summary>
        /// Number of GOT page table entries
        /// </summary>
        public const int DT_MIPS_HIPAGENO = 0x70000014;
        
        /// <summary>
        /// Address of run time loader map.
        /// </summary>
        public const int DT_MIPS_RLD_MAP = 0x70000016;
        
        /// <summary>
        /// Delta C++ class definition.
        /// </summary>
        public const int DT_MIPS_DELTA_CLASS = 0x70000017;
        
        /// <summary>
        /// Number of entries in
        /// DT_MIPS_DELTA_CLASS.
        /// </summary>
        public const int DT_MIPS_DELTA_CLASS_NO = 0x70000018;
        
        /// <summary>
        /// Delta C++ class instances.
        /// </summary>
        public const int DT_MIPS_DELTA_INSTANCE = 0x70000019;
        
        /// <summary>
        /// Number of entries in
        /// DT_MIPS_DELTA_INSTANCE.
        /// </summary>
        public const int DT_MIPS_DELTA_INSTANCE_NO = 0x7000001a;
        
        /// <summary>
        /// Delta relocations.
        /// </summary>
        public const int DT_MIPS_DELTA_RELOC = 0x7000001b;
        
        /// <summary>
        /// Number of entries in
        /// DT_MIPS_DELTA_RELOC.
        /// </summary>
        public const int DT_MIPS_DELTA_RELOC_NO = 0x7000001c;
        
        /// <summary>
        /// Delta symbols that Delta
        /// relocations refer to.
        /// </summary>
        public const int DT_MIPS_DELTA_SYM = 0x7000001d;
        
        /// <summary>
        /// Number of entries in
        /// DT_MIPS_DELTA_SYM.
        /// </summary>
        public const int DT_MIPS_DELTA_SYM_NO = 0x7000001e;
        
        /// <summary>
        /// Delta symbols that hold the
        /// class declaration.
        /// </summary>
        public const int DT_MIPS_DELTA_CLASSSYM = 0x70000020;
        
        /// <summary>
        /// Number of entries in
        /// DT_MIPS_DELTA_CLASSSYM.
        /// </summary>
        public const int DT_MIPS_DELTA_CLASSSYM_NO = 0x70000021;
        
        /// <summary>
        /// Flags indicating for C++ flavor.
        /// </summary>
        public const int DT_MIPS_CXX_FLAGS = 0x70000022;
        
        public const int DT_MIPS_PIXIE_INIT = 0x70000023;
        
        public const int DT_MIPS_SYMBOL_LIB = 0x70000024;
        
        public const int DT_MIPS_LOCALPAGE_GOTIDX = 0x70000025;
        
        public const int DT_MIPS_LOCAL_GOTIDX = 0x70000026;
        
        public const int DT_MIPS_HIDDEN_GOTIDX = 0x70000027;
        
        public const int DT_MIPS_PROTECTED_GOTIDX = 0x70000028;
        
        /// <summary>
        /// Address of .options.
        /// </summary>
        public const int DT_MIPS_OPTIONS = 0x70000029;
        
        /// <summary>
        /// Address of .interface.
        /// </summary>
        public const int DT_MIPS_INTERFACE = 0x7000002a;
        
        public const int DT_MIPS_DYNSTR_ALIGN = 0x7000002b;
        
        /// <summary>
        /// Size of the .interface section.
        /// </summary>
        public const int DT_MIPS_INTERFACE_SIZE = 0x7000002c;
        
        /// <summary>
        /// Address of rld_text_rsolve
        /// function stored in GOT.
        /// </summary>
        public const int DT_MIPS_RLD_TEXT_RESOLVE_ADDR = 0x7000002d;
        
        /// <summary>
        /// Default suffix of dso to be added
        /// by rld on dlopen() calls.
        /// </summary>
        public const int DT_MIPS_PERF_SUFFIX = 0x7000002e;
        
        /// <summary>
        /// (O32)Size of compact rel section.
        /// </summary>
        public const int DT_MIPS_COMPACT_SIZE = 0x7000002f;
        
        /// <summary>
        /// GP value for aux GOTs.
        /// </summary>
        public const int DT_MIPS_GP_VALUE = 0x70000030;
        
        /// <summary>
        /// Address of aux .dynamic.
        /// </summary>
        public const int DT_MIPS_AUX_DYNAMIC = 0x70000031;
        
        public const int DT_MIPS_PLTGOT = 0x70000032;
        
        public const int DT_MIPS_RWPLT = 0x70000034;
        
        public const int DT_MIPS_RLD_MAP_REL = 0x70000035;
        
        public const int DT_MIPS_NUM = 0x36;
        
        /// <summary>
        /// Trap nil pointer dereference.
        /// </summary>
        public const uint EF_PARISC_TRAPNIL = 65536;
        
        /// <summary>
        /// Program uses arch. extensions.
        /// </summary>
        public const uint EF_PARISC_EXT = 131072;
        
        /// <summary>
        /// Program expects little endian.
        /// </summary>
        public const uint EF_PARISC_LSB = 262144;
        
        /// <summary>
        /// Program expects wide mode.
        /// </summary>
        public const uint EF_PARISC_WIDE = 524288;
        
        /// <summary>
        /// No kernel assisted branch
        /// prediction.
        /// </summary>
        public const uint EF_PARISC_NO_KABP = 1048576;
        
        /// <summary>
        /// Allow lazy swapping.
        /// </summary>
        public const uint EF_PARISC_LAZYSWAP = 4194304;
        
        /// <summary>
        /// Architecture version.
        /// </summary>
        public const uint EF_PARISC_ARCH = 65535;
        
        /// <summary>
        /// Section for tenatively declared
        /// symbols in ANSI C.
        /// </summary>
        public const uint SHN_PARISC_ANSI_COMMON = 65280;
        
        /// <summary>
        /// Common blocks in huge model.
        /// </summary>
        public const uint SHN_PARISC_HUGE_COMMON = 65281;
        
        /// <summary>
        /// Contains product specific ext.
        /// </summary>
        public const uint SHT_PARISC_EXT = 1879048192;
        
        /// <summary>
        /// Unwind information.
        /// </summary>
        public const uint SHT_PARISC_UNWIND = 1879048193;
        
        /// <summary>
        /// Debug info for optimized code.
        /// </summary>
        public const uint SHT_PARISC_DOC = 1879048194;
        
        /// <summary>
        /// Section with short addressing.
        /// </summary>
        public const uint SHF_PARISC_SHORT = 536870912;
        
        /// <summary>
        /// Section far from gp.
        /// </summary>
        public const uint SHF_PARISC_HUGE = 1073741824;
        
        /// <summary>
        /// Static branch prediction code.
        /// </summary>
        public const uint SHF_PARISC_SBP = 0x80000000;
        
        /// <summary>
        /// Millicode function entry point.
        /// </summary>
        public const byte STT_PARISC_MILLICODE = 13;
        
        public const byte STT_HP_OPAQUE = 11;
        
        public const byte STT_HP_STUB = 12;
        
        public const uint PT_HP_TLS = 1610612736;
        
        public const uint PT_HP_CORE_NONE = 1610612737;
        
        public const uint PT_HP_CORE_VERSION = 1610612738;
        
        public const uint PT_HP_CORE_KERNEL = 1610612739;
        
        public const uint PT_HP_CORE_COMM = 1610612740;
        
        public const uint PT_HP_CORE_PROC = 1610612741;
        
        public const uint PT_HP_CORE_LOADABLE = 1610612742;
        
        public const uint PT_HP_CORE_STACK = 1610612743;
        
        public const uint PT_HP_CORE_SHM = 1610612744;
        
        public const uint PT_HP_CORE_MMF = 1610612745;
        
        public const uint PT_HP_PARALLEL = 1610612752;
        
        public const uint PT_HP_FASTBIND = 1610612753;
        
        public const uint PT_HP_OPT_ANNOT = 1610612754;
        
        public const uint PT_HP_HSL_ANNOT = 1610612755;
        
        public const uint PT_HP_STACK = 1610612756;
        
        public const uint PT_PARISC_ARCHEXT = 1879048192;
        
        public const uint PT_PARISC_UNWIND = 1879048193;
        
        public const uint PF_PARISC_SBP = 134217728;
        
        public const uint PF_HP_PAGE_SIZE = 1048576;
        
        public const uint PF_HP_FAR_SHARED = 2097152;
        
        public const uint PF_HP_NEAR_SHARED = 4194304;
        
        public const uint PF_HP_CODE = 16777216;
        
        public const uint PF_HP_MODIFY = 33554432;
        
        public const uint PF_HP_LAZYSWAP = 67108864;
        
        public const uint PF_HP_SBP = 134217728;
        
        /// <summary>
        /// All addresses must be 
        /// &lt;
        /// 2GB.
        /// </summary>
        public const uint EF_ALPHA_32BIT = 1;
        
        /// <summary>
        /// Relocations for relaxing exist.
        /// </summary>
        public const uint EF_ALPHA_CANRELAX = 2;
        
        public const uint SHT_ALPHA_DEBUG = 1879048193;
        
        public const uint SHT_ALPHA_REGINFO = 1879048194;
        
        public const uint SHF_ALPHA_GPREL = 268435456;
        
        public const int DT_ALPHA_PLTRO = (  0);
        
        public const int DT_ALPHA_NUM = 1;
        
        /// <summary>
        /// PowerPC embedded flag
        /// </summary>
        public const uint EF_PPC_EMB = 0x80000000;
        
        /// <summary>
        /// PowerPC -mrelocatable flag
        /// </summary>
        public const uint EF_PPC_RELOCATABLE = 65536;
        
        /// <summary>
        /// PowerPC -mrelocatable-lib
        /// flag
        /// </summary>
        public const uint EF_PPC_RELOCATABLE_LIB = 32768;
        
        public const int DT_PPC_GOT = (  0);
        
        public const int DT_PPC_OPT = (  1);
        
        public const int DT_PPC_NUM = 2;
        
        public const uint EF_PPC64_ABI = 3;
        
        public const int DT_PPC64_GLINK = (  0);
        
        public const int DT_PPC64_OPD = (  1);
        
        public const int DT_PPC64_OPDSZ = (  2);
        
        public const int DT_PPC64_OPT = (  3);
        
        public const int DT_PPC64_NUM = 4;
        
        public const uint EF_ARM_RELEXEC = 1;
        
        public const uint EF_ARM_HASENTRY = 2;
        
        public const uint EF_ARM_INTERWORK = 4;
        
        public const uint EF_ARM_APCS_26 = 8;
        
        public const uint EF_ARM_APCS_FLOAT = 16;
        
        public const uint EF_ARM_PIC = 32;
        
        /// <summary>
        /// 8-bit structure alignment is in use
        /// </summary>
        public const uint EF_ARM_ALIGN8 = 64;
        
        public const uint EF_ARM_NEW_ABI = 128;
        
        public const uint EF_ARM_OLD_ABI = 256;
        
        public const uint EF_ARM_SOFT_FLOAT = 512;
        
        public const uint EF_ARM_VFP_FLOAT = 1024;
        
        public const uint EF_ARM_MAVERICK_FLOAT = 2048;
        
        /// <summary>
        /// NB conflicts with EF_ARM_SOFT_FLOAT
        /// </summary>
        public const uint EF_ARM_ABI_FLOAT_SOFT = 512;
        
        /// <summary>
        /// NB conflicts with EF_ARM_VFP_FLOAT
        /// </summary>
        public const uint EF_ARM_ABI_FLOAT_HARD = 1024;
        
        public const uint EF_ARM_SYMSARESORTED = 4;
        
        public const uint EF_ARM_DYNSYMSUSESEGIDX = 8;
        
        public const uint EF_ARM_MAPSYMSFIRST = 16;
        
        public const uint EF_ARM_EABIMASK = 0XFF000000;
        
        public const uint EF_ARM_BE8 = 8388608;
        
        public const uint EF_ARM_LE8 = 4194304;
        
        public const uint EF_ARM_EABI_UNKNOWN = 0;
        
        public const uint EF_ARM_EABI_VER1 = 16777216;
        
        public const uint EF_ARM_EABI_VER2 = 33554432;
        
        public const uint EF_ARM_EABI_VER3 = 50331648;
        
        public const uint EF_ARM_EABI_VER4 = 67108864;
        
        public const uint EF_ARM_EABI_VER5 = 83886080;
        
        /// <summary>
        /// A Thumb function.
        /// </summary>
        public const byte STT_ARM_TFUNC = 13;
        
        /// <summary>
        /// A Thumb label.
        /// </summary>
        public const byte STT_ARM_16BIT = 15;
        
        /// <summary>
        /// Section contains an entry point
        /// </summary>
        public const uint SHF_ARM_ENTRYSECT = 268435456;
        
        /// <summary>
        /// Section may be multiply defined
        /// in the input to a link step.
        /// </summary>
        public const uint SHF_ARM_COMDEF = 0x80000000;
        
        /// <summary>
        /// Segment contains the location
        /// addressed by the static base.
        /// </summary>
        public const uint PF_ARM_SB = 268435456;
        
        /// <summary>
        /// Position-independent segment.
        /// </summary>
        public const uint PF_ARM_PI = 536870912;
        
        /// <summary>
        /// Absolute segment.
        /// </summary>
        public const uint PF_ARM_ABS = 1073741824;
        
        /// <summary>
        /// ARM unwind segment.
        /// </summary>
        public const uint PT_ARM_EXIDX = 1879048193;
        
        /// <summary>
        /// ARM unwind section.
        /// </summary>
        public const uint SHT_ARM_EXIDX = 1879048193;
        
        /// <summary>
        /// Preemption details.
        /// </summary>
        public const uint SHT_ARM_PREEMPTMAP = 1879048194;
        
        /// <summary>
        /// ARM attributes section.
        /// </summary>
        public const uint SHT_ARM_ATTRIBUTES = 1879048195;
        
        /// <summary>
        /// No relocation.
        /// </summary>
        public const uint R_AARCH64_NONE = 0;
        
        /// <summary>
        /// Direct 32 bit.
        /// </summary>
        public const uint R_AARCH64_P32_ABS32 = 1;
        
        /// <summary>
        /// Copy symbol at runtime.
        /// </summary>
        public const uint R_AARCH64_P32_COPY = 180;
        
        /// <summary>
        /// Create GOT entry.
        /// </summary>
        public const uint R_AARCH64_P32_GLOB_DAT = 181;
        
        /// <summary>
        /// Create PLT entry.
        /// </summary>
        public const uint R_AARCH64_P32_JUMP_SLOT = 182;
        
        /// <summary>
        /// Adjust by program base.
        /// </summary>
        public const uint R_AARCH64_P32_RELATIVE = 183;
        
        /// <summary>
        /// Module number, 32 bit.
        /// </summary>
        public const uint R_AARCH64_P32_TLS_DTPMOD = 184;
        
        /// <summary>
        /// Module-relative offset, 32 bit.
        /// </summary>
        public const uint R_AARCH64_P32_TLS_DTPREL = 185;
        
        /// <summary>
        /// TP-relative offset, 32 bit.
        /// </summary>
        public const uint R_AARCH64_P32_TLS_TPREL = 186;
        
        /// <summary>
        /// TLS Descriptor.
        /// </summary>
        public const uint R_AARCH64_P32_TLSDESC = 187;
        
        /// <summary>
        /// STT_GNU_IFUNC relocation.
        /// </summary>
        public const uint R_AARCH64_P32_IRELATIVE = 188;
        
        /// <summary>
        /// Direct 64 bit.
        /// </summary>
        public const uint R_AARCH64_ABS64 = 257;
        
        /// <summary>
        /// Direct 32 bit.
        /// </summary>
        public const uint R_AARCH64_ABS32 = 258;
        
        /// <summary>
        /// Direct 16-bit.
        /// </summary>
        public const uint R_AARCH64_ABS16 = 259;
        
        /// <summary>
        /// PC-relative 64-bit.
        /// </summary>
        public const uint R_AARCH64_PREL64 = 260;
        
        /// <summary>
        /// PC-relative 32-bit.
        /// </summary>
        public const uint R_AARCH64_PREL32 = 261;
        
        /// <summary>
        /// PC-relative 16-bit.
        /// </summary>
        public const uint R_AARCH64_PREL16 = 262;
        
        /// <summary>
        /// Dir. MOVZ imm. from bits 15:0.
        /// </summary>
        public const uint R_AARCH64_MOVW_UABS_G0 = 263;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_UABS_G0_NC = 264;
        
        /// <summary>
        /// Dir. MOVZ imm. from bits 31:16.
        /// </summary>
        public const uint R_AARCH64_MOVW_UABS_G1 = 265;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_UABS_G1_NC = 266;
        
        /// <summary>
        /// Dir. MOVZ imm. from bits 47:32.
        /// </summary>
        public const uint R_AARCH64_MOVW_UABS_G2 = 267;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_UABS_G2_NC = 268;
        
        /// <summary>
        /// Dir. MOV{K,Z} imm. from 63:48.
        /// </summary>
        public const uint R_AARCH64_MOVW_UABS_G3 = 269;
        
        /// <summary>
        /// Dir. MOV{N,Z} imm. from 15:0.
        /// </summary>
        public const uint R_AARCH64_MOVW_SABS_G0 = 270;
        
        /// <summary>
        /// Dir. MOV{N,Z} imm. from 31:16.
        /// </summary>
        public const uint R_AARCH64_MOVW_SABS_G1 = 271;
        
        /// <summary>
        /// Dir. MOV{N,Z} imm. from 47:32.
        /// </summary>
        public const uint R_AARCH64_MOVW_SABS_G2 = 272;
        
        /// <summary>
        /// PC-rel. LD imm. from bits 20:2.
        /// </summary>
        public const uint R_AARCH64_LD_PREL_LO19 = 273;
        
        /// <summary>
        /// PC-rel. ADR imm. from bits 20:0.
        /// </summary>
        public const uint R_AARCH64_ADR_PREL_LO21 = 274;
        
        /// <summary>
        /// Page-rel. ADRP imm. from 32:12.
        /// </summary>
        public const uint R_AARCH64_ADR_PREL_PG_HI21 = 275;
        
        /// <summary>
        /// Likewise; no overflow check.
        /// </summary>
        public const uint R_AARCH64_ADR_PREL_PG_HI21_NC = 276;
        
        /// <summary>
        /// Dir. ADD imm. from bits 11:0.
        /// </summary>
        public const uint R_AARCH64_ADD_ABS_LO12_NC = 277;
        
        /// <summary>
        /// Likewise for LD/ST; no check.
        /// </summary>
        public const uint R_AARCH64_LDST8_ABS_LO12_NC = 278;
        
        /// <summary>
        /// PC-rel. TBZ/TBNZ imm. from 15:2.
        /// </summary>
        public const uint R_AARCH64_TSTBR14 = 279;
        
        /// <summary>
        /// PC-rel. cond. br. imm. from 20:2.
        /// </summary>
        public const uint R_AARCH64_CONDBR19 = 280;
        
        /// <summary>
        /// PC-rel. B imm. from bits 27:2.
        /// </summary>
        public const uint R_AARCH64_JUMP26 = 282;
        
        /// <summary>
        /// Likewise for CALL.
        /// </summary>
        public const uint R_AARCH64_CALL26 = 283;
        
        /// <summary>
        /// Dir. ADD imm. from bits 11:1.
        /// </summary>
        public const uint R_AARCH64_LDST16_ABS_LO12_NC = 284;
        
        /// <summary>
        /// Likewise for bits 11:2.
        /// </summary>
        public const uint R_AARCH64_LDST32_ABS_LO12_NC = 285;
        
        /// <summary>
        /// Likewise for bits 11:3.
        /// </summary>
        public const uint R_AARCH64_LDST64_ABS_LO12_NC = 286;
        
        /// <summary>
        /// PC-rel. MOV{N,Z} imm. from 15:0.
        /// </summary>
        public const uint R_AARCH64_MOVW_PREL_G0 = 287;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_PREL_G0_NC = 288;
        
        /// <summary>
        /// PC-rel. MOV{N,Z} imm. from 31:16.
        /// </summary>
        public const uint R_AARCH64_MOVW_PREL_G1 = 289;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_PREL_G1_NC = 290;
        
        /// <summary>
        /// PC-rel. MOV{N,Z} imm. from 47:32.
        /// </summary>
        public const uint R_AARCH64_MOVW_PREL_G2 = 291;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_PREL_G2_NC = 292;
        
        /// <summary>
        /// PC-rel. MOV{N,Z} imm. from 63:48.
        /// </summary>
        public const uint R_AARCH64_MOVW_PREL_G3 = 293;
        
        /// <summary>
        /// Dir. ADD imm. from bits 11:4.
        /// </summary>
        public const uint R_AARCH64_LDST128_ABS_LO12_NC = 299;
        
        /// <summary>
        /// GOT-rel. off. MOV{N,Z} imm. 15:0.
        /// </summary>
        public const uint R_AARCH64_MOVW_GOTOFF_G0 = 300;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_GOTOFF_G0_NC = 301;
        
        /// <summary>
        /// GOT-rel. o. MOV{N,Z} imm. 31:16.
        /// </summary>
        public const uint R_AARCH64_MOVW_GOTOFF_G1 = 302;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_GOTOFF_G1_NC = 303;
        
        /// <summary>
        /// GOT-rel. o. MOV{N,Z} imm. 47:32.
        /// </summary>
        public const uint R_AARCH64_MOVW_GOTOFF_G2 = 304;
        
        /// <summary>
        /// Likewise for MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_MOVW_GOTOFF_G2_NC = 305;
        
        /// <summary>
        /// GOT-rel. o. MOV{N,Z} imm. 63:48.
        /// </summary>
        public const uint R_AARCH64_MOVW_GOTOFF_G3 = 306;
        
        /// <summary>
        /// GOT-relative 64-bit.
        /// </summary>
        public const uint R_AARCH64_GOTREL64 = 307;
        
        /// <summary>
        /// GOT-relative 32-bit.
        /// </summary>
        public const uint R_AARCH64_GOTREL32 = 308;
        
        /// <summary>
        /// PC-rel. GOT off. load imm. 20:2.
        /// </summary>
        public const uint R_AARCH64_GOT_LD_PREL19 = 309;
        
        /// <summary>
        /// GOT-rel. off. LD/ST imm. 14:3.
        /// </summary>
        public const uint R_AARCH64_LD64_GOTOFF_LO15 = 310;
        
        /// <summary>
        /// P-page-rel. GOT off. ADRP 32:12.
        /// </summary>
        public const uint R_AARCH64_ADR_GOT_PAGE = 311;
        
        /// <summary>
        /// Dir. GOT off. LD/ST imm. 11:3.
        /// </summary>
        public const uint R_AARCH64_LD64_GOT_LO12_NC = 312;
        
        /// <summary>
        /// GOT-page-rel. GOT off. LD/ST 14:3
        /// </summary>
        public const uint R_AARCH64_LD64_GOTPAGE_LO15 = 313;
        
        /// <summary>
        /// PC-relative ADR imm. 20:0.
        /// </summary>
        public const uint R_AARCH64_TLSGD_ADR_PREL21 = 512;
        
        /// <summary>
        /// page-rel. ADRP imm. 32:12.
        /// </summary>
        public const uint R_AARCH64_TLSGD_ADR_PAGE21 = 513;
        
        /// <summary>
        /// direct ADD imm. from 11:0.
        /// </summary>
        public const uint R_AARCH64_TLSGD_ADD_LO12_NC = 514;
        
        /// <summary>
        /// GOT-rel. MOV{N,Z} 31:16.
        /// </summary>
        public const uint R_AARCH64_TLSGD_MOVW_G1 = 515;
        
        /// <summary>
        /// GOT-rel. MOVK imm. 15:0.
        /// </summary>
        public const uint R_AARCH64_TLSGD_MOVW_G0_NC = 516;
        
        /// <summary>
        /// Like 512; local dynamic model.
        /// </summary>
        public const uint R_AARCH64_TLSLD_ADR_PREL21 = 517;
        
        /// <summary>
        /// Like 513; local dynamic model.
        /// </summary>
        public const uint R_AARCH64_TLSLD_ADR_PAGE21 = 518;
        
        /// <summary>
        /// Like 514; local dynamic model.
        /// </summary>
        public const uint R_AARCH64_TLSLD_ADD_LO12_NC = 519;
        
        /// <summary>
        /// Like 515; local dynamic model.
        /// </summary>
        public const uint R_AARCH64_TLSLD_MOVW_G1 = 520;
        
        /// <summary>
        /// Like 516; local dynamic model.
        /// </summary>
        public const uint R_AARCH64_TLSLD_MOVW_G0_NC = 521;
        
        /// <summary>
        /// TLS PC-rel. load imm. 20:2.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LD_PREL19 = 522;
        
        /// <summary>
        /// TLS DTP-rel. MOV{N,Z} 47:32.
        /// </summary>
        public const uint R_AARCH64_TLSLD_MOVW_DTPREL_G2 = 523;
        
        /// <summary>
        /// TLS DTP-rel. MOV{N,Z} 31:16.
        /// </summary>
        public const uint R_AARCH64_TLSLD_MOVW_DTPREL_G1 = 524;
        
        /// <summary>
        /// Likewise; MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC = 525;
        
        /// <summary>
        /// TLS DTP-rel. MOV{N,Z} 15:0.
        /// </summary>
        public const uint R_AARCH64_TLSLD_MOVW_DTPREL_G0 = 526;
        
        /// <summary>
        /// Likewise; MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC = 527;
        
        /// <summary>
        /// DTP-rel. ADD imm. from 23:12.
        /// </summary>
        public const uint R_AARCH64_TLSLD_ADD_DTPREL_HI12 = 528;
        
        /// <summary>
        /// DTP-rel. ADD imm. from 11:0.
        /// </summary>
        public const uint R_AARCH64_TLSLD_ADD_DTPREL_LO12 = 529;
        
        /// <summary>
        /// Likewise; no ovfl. check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC = 530;
        
        /// <summary>
        /// DTP-rel. LD/ST imm. 11:0.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST8_DTPREL_LO12 = 531;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC = 532;
        
        /// <summary>
        /// DTP-rel. LD/ST imm. 11:1.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST16_DTPREL_LO12 = 533;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC = 534;
        
        /// <summary>
        /// DTP-rel. LD/ST imm. 11:2.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST32_DTPREL_LO12 = 535;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC = 536;
        
        /// <summary>
        /// DTP-rel. LD/ST imm. 11:3.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST64_DTPREL_LO12 = 537;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC = 538;
        
        /// <summary>
        /// GOT-rel. MOV{N,Z} 31:16.
        /// </summary>
        public const uint R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 = 539;
        
        /// <summary>
        /// GOT-rel. MOVK 15:0.
        /// </summary>
        public const uint R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC = 540;
        
        /// <summary>
        /// Page-rel. ADRP 32:12.
        /// </summary>
        public const uint R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 = 541;
        
        /// <summary>
        /// Direct LD off. 11:3.
        /// </summary>
        public const uint R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC = 542;
        
        /// <summary>
        /// PC-rel. load imm. 20:2.
        /// </summary>
        public const uint R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 = 543;
        
        /// <summary>
        /// TLS TP-rel. MOV{N,Z} 47:32.
        /// </summary>
        public const uint R_AARCH64_TLSLE_MOVW_TPREL_G2 = 544;
        
        /// <summary>
        /// TLS TP-rel. MOV{N,Z} 31:16.
        /// </summary>
        public const uint R_AARCH64_TLSLE_MOVW_TPREL_G1 = 545;
        
        /// <summary>
        /// Likewise; MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_MOVW_TPREL_G1_NC = 546;
        
        /// <summary>
        /// TLS TP-rel. MOV{N,Z} 15:0.
        /// </summary>
        public const uint R_AARCH64_TLSLE_MOVW_TPREL_G0 = 547;
        
        /// <summary>
        /// Likewise; MOVK; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_MOVW_TPREL_G0_NC = 548;
        
        /// <summary>
        /// TP-rel. ADD imm. 23:12.
        /// </summary>
        public const uint R_AARCH64_TLSLE_ADD_TPREL_HI12 = 549;
        
        /// <summary>
        /// TP-rel. ADD imm. 11:0.
        /// </summary>
        public const uint R_AARCH64_TLSLE_ADD_TPREL_LO12 = 550;
        
        /// <summary>
        /// Likewise; no ovfl. check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_ADD_TPREL_LO12_NC = 551;
        
        /// <summary>
        /// TP-rel. LD/ST off. 11:0.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST8_TPREL_LO12 = 552;
        
        /// <summary>
        /// Likewise; no ovfl. check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC = 553;
        
        /// <summary>
        /// TP-rel. LD/ST off. 11:1.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST16_TPREL_LO12 = 554;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC = 555;
        
        /// <summary>
        /// TP-rel. LD/ST off. 11:2.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST32_TPREL_LO12 = 556;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC = 557;
        
        /// <summary>
        /// TP-rel. LD/ST off. 11:3.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST64_TPREL_LO12 = 558;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC = 559;
        
        /// <summary>
        /// PC-rel. load immediate 20:2.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_LD_PREL19 = 560;
        
        /// <summary>
        /// PC-rel. ADR immediate 20:0.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_ADR_PREL21 = 561;
        
        /// <summary>
        /// Page-rel. ADRP imm. 32:12.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_ADR_PAGE21 = 562;
        
        /// <summary>
        /// Direct LD off. from 11:3.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_LD64_LO12 = 563;
        
        /// <summary>
        /// Direct ADD imm. from 11:0.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_ADD_LO12 = 564;
        
        /// <summary>
        /// GOT-rel. MOV{N,Z} imm. 31:16.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_OFF_G1 = 565;
        
        /// <summary>
        /// GOT-rel. MOVK imm. 15:0; no ck.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_OFF_G0_NC = 566;
        
        /// <summary>
        /// Relax LDR.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_LDR = 567;
        
        /// <summary>
        /// Relax ADD.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_ADD = 568;
        
        /// <summary>
        /// Relax BLR.
        /// </summary>
        public const uint R_AARCH64_TLSDESC_CALL = 569;
        
        /// <summary>
        /// TP-rel. LD/ST off. 11:4.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST128_TPREL_LO12 = 570;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC = 571;
        
        /// <summary>
        /// DTP-rel. LD/ST imm. 11:4.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST128_DTPREL_LO12 = 572;
        
        /// <summary>
        /// Likewise; no check.
        /// </summary>
        public const uint R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC = 573;
        
        /// <summary>
        /// Copy symbol at runtime.
        /// </summary>
        public const uint R_AARCH64_COPY = 1024;
        
        /// <summary>
        /// Create GOT entry.
        /// </summary>
        public const uint R_AARCH64_GLOB_DAT = 1025;
        
        /// <summary>
        /// Create PLT entry.
        /// </summary>
        public const uint R_AARCH64_JUMP_SLOT = 1026;
        
        /// <summary>
        /// Adjust by program base.
        /// </summary>
        public const uint R_AARCH64_RELATIVE = 1027;
        
        /// <summary>
        /// Module number, 64 bit.
        /// </summary>
        public const uint R_AARCH64_TLS_DTPMOD = 1028;
        
        /// <summary>
        /// Module-relative offset, 64 bit.
        /// </summary>
        public const uint R_AARCH64_TLS_DTPREL = 1029;
        
        /// <summary>
        /// TP-relative offset, 64 bit.
        /// </summary>
        public const uint R_AARCH64_TLS_TPREL = 1030;
        
        /// <summary>
        /// TLS Descriptor.
        /// </summary>
        public const uint R_AARCH64_TLSDESC = 1031;
        
        /// <summary>
        /// STT_GNU_IFUNC relocation.
        /// </summary>
        public const uint R_AARCH64_IRELATIVE = 1032;
        
        /// <summary>
        /// No reloc
        /// </summary>
        public const uint R_ARM_NONE = 0;
        
        /// <summary>
        /// Deprecated PC relative 26 bit branch.
        /// </summary>
        public const uint R_ARM_PC24 = 1;
        
        /// <summary>
        /// Direct 32 bit
        /// </summary>
        public const uint R_ARM_ABS32 = 2;
        
        /// <summary>
        /// PC relative 32 bit
        /// </summary>
        public const uint R_ARM_REL32 = 3;
        
        public const uint R_ARM_PC13 = 4;
        
        /// <summary>
        /// Direct 16 bit
        /// </summary>
        public const uint R_ARM_ABS16 = 5;
        
        /// <summary>
        /// Direct 12 bit
        /// </summary>
        public const uint R_ARM_ABS12 = 6;
        
        /// <summary>
        /// Direct 
        /// &amp;
        /// 0x7C (LDR, STR).
        /// </summary>
        public const uint R_ARM_THM_ABS5 = 7;
        
        /// <summary>
        /// Direct 8 bit
        /// </summary>
        public const uint R_ARM_ABS8 = 8;
        
        public const uint R_ARM_SBREL32 = 9;
        
        /// <summary>
        /// PC relative 24 bit (Thumb32 BL).
        /// </summary>
        public const uint R_ARM_THM_PC22 = 10;
        
        /// <summary>
        /// PC relative 
        /// &amp;
        /// 0x3FC (Thumb16 LDR, ADD, ADR).
        /// </summary>
        public const uint R_ARM_THM_PC8 = 11;
        
        public const uint R_ARM_AMP_VCALL9 = 12;
        
        /// <summary>
        /// Obsolete static relocation.
        /// </summary>
        public const uint R_ARM_SWI24 = 13;
        
        /// <summary>
        /// Dynamic relocation.
        /// </summary>
        public const uint R_ARM_TLS_DESC = 13;
        
        /// <summary>
        /// Reserved.
        /// </summary>
        public const uint R_ARM_THM_SWI8 = 14;
        
        /// <summary>
        /// Reserved.
        /// </summary>
        public const uint R_ARM_XPC25 = 15;
        
        /// <summary>
        /// Reserved.
        /// </summary>
        public const uint R_ARM_THM_XPC22 = 16;
        
        /// <summary>
        /// ID of module containing symbol
        /// </summary>
        public const uint R_ARM_TLS_DTPMOD32 = 17;
        
        /// <summary>
        /// Offset in TLS block
        /// </summary>
        public const uint R_ARM_TLS_DTPOFF32 = 18;
        
        /// <summary>
        /// Offset in static TLS block
        /// </summary>
        public const uint R_ARM_TLS_TPOFF32 = 19;
        
        /// <summary>
        /// Copy symbol at runtime
        /// </summary>
        public const uint R_ARM_COPY = 20;
        
        /// <summary>
        /// Create GOT entry
        /// </summary>
        public const uint R_ARM_GLOB_DAT = 21;
        
        /// <summary>
        /// Create PLT entry
        /// </summary>
        public const uint R_ARM_JUMP_SLOT = 22;
        
        /// <summary>
        /// Adjust by program base
        /// </summary>
        public const uint R_ARM_RELATIVE = 23;
        
        /// <summary>
        /// 32 bit offset to GOT
        /// </summary>
        public const uint R_ARM_GOTOFF = 24;
        
        /// <summary>
        /// 32 bit PC relative offset to GOT
        /// </summary>
        public const uint R_ARM_GOTPC = 25;
        
        /// <summary>
        /// 32 bit GOT entry
        /// </summary>
        public const uint R_ARM_GOT32 = 26;
        
        /// <summary>
        /// Deprecated, 32 bit PLT address.
        /// </summary>
        public const uint R_ARM_PLT32 = 27;
        
        /// <summary>
        /// PC relative 24 bit (BL, BLX).
        /// </summary>
        public const uint R_ARM_CALL = 28;
        
        /// <summary>
        /// PC relative 24 bit (B, BL
        /// &lt;cond
        /// &gt;).
        /// </summary>
        public const uint R_ARM_JUMP24 = 29;
        
        /// <summary>
        /// PC relative 24 bit (Thumb32 B.W).
        /// </summary>
        public const uint R_ARM_THM_JUMP24 = 30;
        
        /// <summary>
        /// Adjust by program base.
        /// </summary>
        public const uint R_ARM_BASE_ABS = 31;
        
        /// <summary>
        /// Obsolete.
        /// </summary>
        public const uint R_ARM_ALU_PCREL_7_0 = 32;
        
        /// <summary>
        /// Obsolete.
        /// </summary>
        public const uint R_ARM_ALU_PCREL_15_8 = 33;
        
        /// <summary>
        /// Obsolete.
        /// </summary>
        public const uint R_ARM_ALU_PCREL_23_15 = 34;
        
        /// <summary>
        /// Deprecated, prog. base relative.
        /// </summary>
        public const uint R_ARM_LDR_SBREL_11_0 = 35;
        
        /// <summary>
        /// Deprecated, prog. base relative.
        /// </summary>
        public const uint R_ARM_ALU_SBREL_19_12 = 36;
        
        /// <summary>
        /// Deprecated, prog. base relative.
        /// </summary>
        public const uint R_ARM_ALU_SBREL_27_20 = 37;
        
        public const uint R_ARM_TARGET1 = 38;
        
        /// <summary>
        /// Program base relative.
        /// </summary>
        public const uint R_ARM_SBREL31 = 39;
        
        public const uint R_ARM_V4BX = 40;
        
        public const uint R_ARM_TARGET2 = 41;
        
        /// <summary>
        /// 32 bit PC relative.
        /// </summary>
        public const uint R_ARM_PREL31 = 42;
        
        /// <summary>
        /// Direct 16-bit (MOVW).
        /// </summary>
        public const uint R_ARM_MOVW_ABS_NC = 43;
        
        /// <summary>
        /// Direct high 16-bit (MOVT).
        /// </summary>
        public const uint R_ARM_MOVT_ABS = 44;
        
        /// <summary>
        /// PC relative 16-bit (MOVW).
        /// </summary>
        public const uint R_ARM_MOVW_PREL_NC = 45;
        
        /// <summary>
        /// PC relative (MOVT).
        /// </summary>
        public const uint R_ARM_MOVT_PREL = 46;
        
        /// <summary>
        /// Direct 16 bit (Thumb32 MOVW).
        /// </summary>
        public const uint R_ARM_THM_MOVW_ABS_NC = 47;
        
        /// <summary>
        /// Direct high 16 bit (Thumb32 MOVT).
        /// </summary>
        public const uint R_ARM_THM_MOVT_ABS = 48;
        
        /// <summary>
        /// PC relative 16 bit (Thumb32 MOVW).
        /// </summary>
        public const uint R_ARM_THM_MOVW_PREL_NC = 49;
        
        /// <summary>
        /// PC relative high 16 bit (Thumb32 MOVT).
        /// </summary>
        public const uint R_ARM_THM_MOVT_PREL = 50;
        
        /// <summary>
        /// PC relative 20 bit (Thumb32 B
        /// &lt;cond
        /// &gt;.W).
        /// </summary>
        public const uint R_ARM_THM_JUMP19 = 51;
        
        /// <summary>
        /// PC relative X 
        /// &amp;
        /// 0x7E (Thumb16 CBZ, CBNZ).
        /// </summary>
        public const uint R_ARM_THM_JUMP6 = 52;
        
        /// <summary>
        /// PC relative 12 bit (Thumb32 ADR.W).
        /// </summary>
        public const uint R_ARM_THM_ALU_PREL_11_0 = 53;
        
        /// <summary>
        /// PC relative 12 bit (Thumb32 LDR{D,SB,H,SH}).
        /// </summary>
        public const uint R_ARM_THM_PC12 = 54;
        
        /// <summary>
        /// Direct 32-bit.
        /// </summary>
        public const uint R_ARM_ABS32_NOI = 55;
        
        /// <summary>
        /// PC relative 32-bit.
        /// </summary>
        public const uint R_ARM_REL32_NOI = 56;
        
        /// <summary>
        /// PC relative (ADD, SUB).
        /// </summary>
        public const uint R_ARM_ALU_PC_G0_NC = 57;
        
        /// <summary>
        /// PC relative (ADD, SUB).
        /// </summary>
        public const uint R_ARM_ALU_PC_G0 = 58;
        
        /// <summary>
        /// PC relative (ADD, SUB).
        /// </summary>
        public const uint R_ARM_ALU_PC_G1_NC = 59;
        
        /// <summary>
        /// PC relative (ADD, SUB).
        /// </summary>
        public const uint R_ARM_ALU_PC_G1 = 60;
        
        /// <summary>
        /// PC relative (ADD, SUB).
        /// </summary>
        public const uint R_ARM_ALU_PC_G2 = 61;
        
        /// <summary>
        /// PC relative (LDR,STR,LDRB,STRB).
        /// </summary>
        public const uint R_ARM_LDR_PC_G1 = 62;
        
        /// <summary>
        /// PC relative (LDR,STR,LDRB,STRB).
        /// </summary>
        public const uint R_ARM_LDR_PC_G2 = 63;
        
        /// <summary>
        /// PC relative (STR{D,H}, LDR{D,SB,H,SH}).
        /// </summary>
        public const uint R_ARM_LDRS_PC_G0 = 64;
        
        /// <summary>
        /// PC relative (STR{D,H}, LDR{D,SB,H,SH}).
        /// </summary>
        public const uint R_ARM_LDRS_PC_G1 = 65;
        
        /// <summary>
        /// PC relative (STR{D,H}, LDR{D,SB,H,SH}).
        /// </summary>
        public const uint R_ARM_LDRS_PC_G2 = 66;
        
        /// <summary>
        /// PC relative (LDC, STC).
        /// </summary>
        public const uint R_ARM_LDC_PC_G0 = 67;
        
        /// <summary>
        /// PC relative (LDC, STC).
        /// </summary>
        public const uint R_ARM_LDC_PC_G1 = 68;
        
        /// <summary>
        /// PC relative (LDC, STC).
        /// </summary>
        public const uint R_ARM_LDC_PC_G2 = 69;
        
        /// <summary>
        /// Program base relative (ADD,SUB).
        /// </summary>
        public const uint R_ARM_ALU_SB_G0_NC = 70;
        
        /// <summary>
        /// Program base relative (ADD,SUB).
        /// </summary>
        public const uint R_ARM_ALU_SB_G0 = 71;
        
        /// <summary>
        /// Program base relative (ADD,SUB).
        /// </summary>
        public const uint R_ARM_ALU_SB_G1_NC = 72;
        
        /// <summary>
        /// Program base relative (ADD,SUB).
        /// </summary>
        public const uint R_ARM_ALU_SB_G1 = 73;
        
        /// <summary>
        /// Program base relative (ADD,SUB).
        /// </summary>
        public const uint R_ARM_ALU_SB_G2 = 74;
        
        /// <summary>
        /// Program base relative (LDR, STR, LDRB, STRB).
        /// </summary>
        public const uint R_ARM_LDR_SB_G0 = 75;
        
        /// <summary>
        /// Program base relative (LDR, STR, LDRB, STRB).
        /// </summary>
        public const uint R_ARM_LDR_SB_G1 = 76;
        
        /// <summary>
        /// Program base relative (LDR, STR, LDRB, STRB).
        /// </summary>
        public const uint R_ARM_LDR_SB_G2 = 77;
        
        /// <summary>
        /// Program base relative (LDR, STR, LDRB, STRB).
        /// </summary>
        public const uint R_ARM_LDRS_SB_G0 = 78;
        
        /// <summary>
        /// Program base relative (LDR, STR, LDRB, STRB).
        /// </summary>
        public const uint R_ARM_LDRS_SB_G1 = 79;
        
        /// <summary>
        /// Program base relative (LDR, STR, LDRB, STRB).
        /// </summary>
        public const uint R_ARM_LDRS_SB_G2 = 80;
        
        /// <summary>
        /// Program base relative (LDC,STC).
        /// </summary>
        public const uint R_ARM_LDC_SB_G0 = 81;
        
        /// <summary>
        /// Program base relative (LDC,STC).
        /// </summary>
        public const uint R_ARM_LDC_SB_G1 = 82;
        
        /// <summary>
        /// Program base relative (LDC,STC).
        /// </summary>
        public const uint R_ARM_LDC_SB_G2 = 83;
        
        /// <summary>
        /// Program base relative 16 bit (MOVW).
        /// </summary>
        public const uint R_ARM_MOVW_BREL_NC = 84;
        
        /// <summary>
        /// Program base relative high 16 bit (MOVT).
        /// </summary>
        public const uint R_ARM_MOVT_BREL = 85;
        
        /// <summary>
        /// Program base relative 16 bit (MOVW).
        /// </summary>
        public const uint R_ARM_MOVW_BREL = 86;
        
        /// <summary>
        /// Program base relative 16 bit (Thumb32 MOVW).
        /// </summary>
        public const uint R_ARM_THM_MOVW_BREL_NC = 87;
        
        /// <summary>
        /// Program base relative high 16 bit (Thumb32 MOVT).
        /// </summary>
        public const uint R_ARM_THM_MOVT_BREL = 88;
        
        /// <summary>
        /// Program base relative 16 bit (Thumb32 MOVW).
        /// </summary>
        public const uint R_ARM_THM_MOVW_BREL = 89;
        
        public const uint R_ARM_TLS_GOTDESC = 90;
        
        public const uint R_ARM_TLS_CALL = 91;
        
        /// <summary>
        /// TLS relaxation.
        /// </summary>
        public const uint R_ARM_TLS_DESCSEQ = 92;
        
        public const uint R_ARM_THM_TLS_CALL = 93;
        
        public const uint R_ARM_PLT32_ABS = 94;
        
        /// <summary>
        /// GOT entry.
        /// </summary>
        public const uint R_ARM_GOT_ABS = 95;
        
        /// <summary>
        /// PC relative GOT entry.
        /// </summary>
        public const uint R_ARM_GOT_PREL = 96;
        
        /// <summary>
        /// GOT entry relative to GOT origin (LDR).
        /// </summary>
        public const uint R_ARM_GOT_BREL12 = 97;
        
        /// <summary>
        /// 12 bit, GOT entry relative to GOT origin (LDR, STR).
        /// </summary>
        public const uint R_ARM_GOTOFF12 = 98;
        
        public const uint R_ARM_GOTRELAX = 99;
        
        public const uint R_ARM_GNU_VTENTRY = 100;
        
        public const uint R_ARM_GNU_VTINHERIT = 101;
        
        /// <summary>
        /// PC relative 
        /// &amp;
        /// 0xFFE (Thumb16 B).
        /// </summary>
        public const uint R_ARM_THM_PC11 = 102;
        
        /// <summary>
        /// PC relative 
        /// &amp;
        /// 0x1FE (Thumb16 B/B
        /// &lt;cond
        /// &gt;).
        /// </summary>
        public const uint R_ARM_THM_PC9 = 103;
        
        /// <summary>
        /// PC-rel 32 bit for global dynamic thread local data
        /// </summary>
        public const uint R_ARM_TLS_GD32 = 104;
        
        /// <summary>
        /// PC-rel 32 bit for local dynamic thread local data
        /// </summary>
        public const uint R_ARM_TLS_LDM32 = 105;
        
        /// <summary>
        /// 32 bit offset relative to TLS block
        /// </summary>
        public const uint R_ARM_TLS_LDO32 = 106;
        
        /// <summary>
        /// PC-rel 32 bit for GOT entry of static TLS block offset
        /// </summary>
        public const uint R_ARM_TLS_IE32 = 107;
        
        /// <summary>
        /// 32 bit offset relative to static TLS block
        /// </summary>
        public const uint R_ARM_TLS_LE32 = 108;
        
        /// <summary>
        /// 12 bit relative to TLS block (LDR, STR).
        /// </summary>
        public const uint R_ARM_TLS_LDO12 = 109;
        
        /// <summary>
        /// 12 bit relative to static TLS block (LDR, STR).
        /// </summary>
        public const uint R_ARM_TLS_LE12 = 110;
        
        /// <summary>
        /// 12 bit GOT entry relative to GOT origin (LDR).
        /// </summary>
        public const uint R_ARM_TLS_IE12GP = 111;
        
        /// <summary>
        /// Obsolete.
        /// </summary>
        public const uint R_ARM_ME_TOO = 128;
        
        public const uint R_ARM_THM_TLS_DESCSEQ = 129;
        
        public const uint R_ARM_THM_TLS_DESCSEQ16 = 129;
        
        public const uint R_ARM_THM_TLS_DESCSEQ32 = 130;
        
        /// <summary>
        /// GOT entry relative to GOT origin, 12 bit (Thumb32 LDR).
        /// </summary>
        public const uint R_ARM_THM_GOT_BREL12 = 131;
        
        public const uint R_ARM_IRELATIVE = 160;
        
        public const uint R_ARM_RXPC25 = 249;
        
        public const uint R_ARM_RSBREL32 = 250;
        
        public const uint R_ARM_THM_RPC22 = 251;
        
        public const uint R_ARM_RREL32 = 252;
        
        public const uint R_ARM_RABS22 = 253;
        
        public const uint R_ARM_RPC24 = 254;
        
        public const uint R_ARM_RBASE = 255;
        
        public const uint R_ARM_NUM = 256;
        
        /// <summary>
        /// os-specific flags
        /// </summary>
        public const uint EF_IA_64_MASKOS = 15;
        
        /// <summary>
        /// 64-bit ABI
        /// </summary>
        public const uint EF_IA_64_ABI64 = 16;
        
        /// <summary>
        /// arch. version mask
        /// </summary>
        public const uint EF_IA_64_ARCH = 0xff000000;
        
        /// <summary>
        /// arch extension bits
        /// </summary>
        public const uint PT_IA_64_ARCHEXT = 1879048192;
        
        /// <summary>
        /// ia64 unwind bits
        /// </summary>
        public const uint PT_IA_64_UNWIND = 1879048193;
        
        public const uint PT_IA_64_HP_OPT_ANOT = 1610612754;
        
        public const uint PT_IA_64_HP_HSL_ANOT = 1610612755;
        
        public const uint PT_IA_64_HP_STACK = 1610612756;
        
        /// <summary>
        /// spec insns w/o recovery
        /// </summary>
        public const uint PF_IA_64_NORECOV = 0x80000000;
        
        /// <summary>
        /// extension bits
        /// </summary>
        public const uint SHT_IA_64_EXT = 1879048192;
        
        /// <summary>
        /// unwind bits
        /// </summary>
        public const uint SHT_IA_64_UNWIND = 1879048193;
        
        /// <summary>
        /// section near gp
        /// </summary>
        public const uint SHF_IA_64_SHORT = 268435456;
        
        /// <summary>
        /// spec insns w/o recovery
        /// </summary>
        public const uint SHF_IA_64_NORECOV = 536870912;
        
        public const int DT_IA_64_PLT_RESERVE = (  0);
        
        public const int DT_IA_64_NUM = 1;
        
        public const uint EF_SH_MACH_MASK = 31;
        
        public const uint EF_SH_UNKNOWN = 0;
        
        public const uint EF_SH1 = 1;
        
        public const uint EF_SH2 = 2;
        
        public const uint EF_SH3 = 3;
        
        public const uint EF_SH_DSP = 4;
        
        public const uint EF_SH3_DSP = 5;
        
        public const uint EF_SH4AL_DSP = 6;
        
        public const uint EF_SH3E = 8;
        
        public const uint EF_SH4 = 9;
        
        public const uint EF_SH2E = 11;
        
        public const uint EF_SH4A = 12;
        
        public const uint EF_SH2A = 13;
        
        public const uint EF_SH4_NOFPU = 16;
        
        public const uint EF_SH4A_NOFPU = 17;
        
        public const uint EF_SH4_NOMMU_NOFPU = 18;
        
        public const uint EF_SH2A_NOFPU = 19;
        
        public const uint EF_SH3_NOMMU = 20;
        
        public const uint EF_SH2A_SH4_NOFPU = 21;
        
        public const uint EF_SH2A_SH3_NOFPU = 22;
        
        public const uint EF_SH2A_SH4 = 23;
        
        public const uint EF_SH2A_SH3E = 24;
        
        /// <summary>
        /// High GPRs kernel facility needed.
        /// </summary>
        public const uint EF_S390_HIGH_GPRS = 1;
        
        /// <summary>
        /// Address of _gp.
        /// </summary>
        public const int DT_NIOS2_GP = 0x70000002;
    }
    
    public readonly partial struct ElfArch
    {
        /// <summary>
        /// No machine
        /// </summary>
        public static readonly ElfArch NONE = new ElfArch(RawElf.EM_NONE);
        
        /// <summary>
        /// AT
        /// &amp;T
        /// WE 32100
        /// </summary>
        public static readonly ElfArch M32 = new ElfArch(RawElf.EM_M32);
        
        /// <summary>
        /// SUN SPARC
        /// </summary>
        public static readonly ElfArch SPARC = new ElfArch(RawElf.EM_SPARC);
        
        /// <summary>
        /// Intel 80386
        /// </summary>
        public static readonly ElfArch I386 = new ElfArch(RawElf.EM_386);
        
        /// <summary>
        /// Motorola m68k family
        /// </summary>
        public static readonly ElfArch M68K = new ElfArch(RawElf.EM_68K);
        
        /// <summary>
        /// Motorola m88k family
        /// </summary>
        public static readonly ElfArch M88K = new ElfArch(RawElf.EM_88K);
        
        /// <summary>
        /// Intel 80860
        /// </summary>
        public static readonly ElfArch I860 = new ElfArch(RawElf.EM_860);
        
        /// <summary>
        /// MIPS R3000 big-endian
        /// </summary>
        public static readonly ElfArch MIPS = new ElfArch(RawElf.EM_MIPS);
        
        /// <summary>
        /// IBM System/370
        /// </summary>
        public static readonly ElfArch S370 = new ElfArch(RawElf.EM_S370);
        
        /// <summary>
        /// MIPS R3000 little-endian
        /// </summary>
        public static readonly ElfArch MIPS_RS3_LE = new ElfArch(RawElf.EM_MIPS_RS3_LE);
        
        /// <summary>
        /// HPPA
        /// </summary>
        public static readonly ElfArch PARISC = new ElfArch(RawElf.EM_PARISC);
        
        /// <summary>
        /// Fujitsu VPP500
        /// </summary>
        public static readonly ElfArch VPP500 = new ElfArch(RawElf.EM_VPP500);
        
        /// <summary>
        /// Sun's "v8plus"
        /// </summary>
        public static readonly ElfArch SPARC32PLUS = new ElfArch(RawElf.EM_SPARC32PLUS);
        
        /// <summary>
        /// Intel 80960
        /// </summary>
        public static readonly ElfArch I960 = new ElfArch(RawElf.EM_960);
        
        /// <summary>
        /// PowerPC
        /// </summary>
        public static readonly ElfArch PPC = new ElfArch(RawElf.EM_PPC);
        
        /// <summary>
        /// PowerPC 64-bit
        /// </summary>
        public static readonly ElfArch PPC64 = new ElfArch(RawElf.EM_PPC64);
        
        /// <summary>
        /// IBM S390
        /// </summary>
        public static readonly ElfArch S390 = new ElfArch(RawElf.EM_S390);
        
        /// <summary>
        /// NEC V800 series
        /// </summary>
        public static readonly ElfArch V800 = new ElfArch(RawElf.EM_V800);
        
        /// <summary>
        /// Fujitsu FR20
        /// </summary>
        public static readonly ElfArch FR20 = new ElfArch(RawElf.EM_FR20);
        
        /// <summary>
        /// TRW RH-32
        /// </summary>
        public static readonly ElfArch RH32 = new ElfArch(RawElf.EM_RH32);
        
        /// <summary>
        /// Motorola RCE
        /// </summary>
        public static readonly ElfArch RCE = new ElfArch(RawElf.EM_RCE);
        
        /// <summary>
        /// ARM
        /// </summary>
        public static readonly ElfArch ARM = new ElfArch(RawElf.EM_ARM);
        
        /// <summary>
        /// Digital Alpha
        /// </summary>
        public static readonly ElfArch FAKE_ALPHA = new ElfArch(RawElf.EM_FAKE_ALPHA);
        
        /// <summary>
        /// Hitachi SH
        /// </summary>
        public static readonly ElfArch SH = new ElfArch(RawElf.EM_SH);
        
        /// <summary>
        /// SPARC v9 64-bit
        /// </summary>
        public static readonly ElfArch SPARCV9 = new ElfArch(RawElf.EM_SPARCV9);
        
        /// <summary>
        /// Siemens Tricore
        /// </summary>
        public static readonly ElfArch TRICORE = new ElfArch(RawElf.EM_TRICORE);
        
        /// <summary>
        /// Argonaut RISC Core
        /// </summary>
        public static readonly ElfArch ARC = new ElfArch(RawElf.EM_ARC);
        
        /// <summary>
        /// Hitachi H8/300
        /// </summary>
        public static readonly ElfArch H8_300 = new ElfArch(RawElf.EM_H8_300);
        
        /// <summary>
        /// Hitachi H8/300H
        /// </summary>
        public static readonly ElfArch H8_300H = new ElfArch(RawElf.EM_H8_300H);
        
        /// <summary>
        /// Hitachi H8S
        /// </summary>
        public static readonly ElfArch H8S = new ElfArch(RawElf.EM_H8S);
        
        /// <summary>
        /// Hitachi H8/500
        /// </summary>
        public static readonly ElfArch H8_500 = new ElfArch(RawElf.EM_H8_500);
        
        /// <summary>
        /// Intel Merced
        /// </summary>
        public static readonly ElfArch IA_64 = new ElfArch(RawElf.EM_IA_64);
        
        /// <summary>
        /// Stanford MIPS-X
        /// </summary>
        public static readonly ElfArch MIPS_X = new ElfArch(RawElf.EM_MIPS_X);
        
        /// <summary>
        /// Motorola Coldfire
        /// </summary>
        public static readonly ElfArch COLDFIRE = new ElfArch(RawElf.EM_COLDFIRE);
        
        /// <summary>
        /// Motorola M68HC12
        /// </summary>
        public static readonly ElfArch M68HC12 = new ElfArch(RawElf.EM_68HC12);
        
        /// <summary>
        /// Fujitsu MMA Multimedia Accelerator
        /// </summary>
        public static readonly ElfArch MMA = new ElfArch(RawElf.EM_MMA);
        
        /// <summary>
        /// Siemens PCP
        /// </summary>
        public static readonly ElfArch PCP = new ElfArch(RawElf.EM_PCP);
        
        /// <summary>
        /// Sony nCPU embeeded RISC
        /// </summary>
        public static readonly ElfArch NCPU = new ElfArch(RawElf.EM_NCPU);
        
        /// <summary>
        /// Denso NDR1 microprocessor
        /// </summary>
        public static readonly ElfArch NDR1 = new ElfArch(RawElf.EM_NDR1);
        
        /// <summary>
        /// Motorola Start*Core processor
        /// </summary>
        public static readonly ElfArch STARCORE = new ElfArch(RawElf.EM_STARCORE);
        
        /// <summary>
        /// Toyota ME16 processor
        /// </summary>
        public static readonly ElfArch ME16 = new ElfArch(RawElf.EM_ME16);
        
        /// <summary>
        /// STMicroelectronic ST100 processor
        /// </summary>
        public static readonly ElfArch ST100 = new ElfArch(RawElf.EM_ST100);
        
        /// <summary>
        /// Advanced Logic Corp. Tinyj emb.fam
        /// </summary>
        public static readonly ElfArch TINYJ = new ElfArch(RawElf.EM_TINYJ);
        
        /// <summary>
        /// AMD x86-64 architecture
        /// </summary>
        public static readonly ElfArch X86_64 = new ElfArch(RawElf.EM_X86_64);
        
        /// <summary>
        /// Sony DSP Processor
        /// </summary>
        public static readonly ElfArch PDSP = new ElfArch(RawElf.EM_PDSP);
        
        /// <summary>
        /// Siemens FX66 microcontroller
        /// </summary>
        public static readonly ElfArch FX66 = new ElfArch(RawElf.EM_FX66);
        
        /// <summary>
        /// STMicroelectronics ST9+ 8/16 mc
        /// </summary>
        public static readonly ElfArch ST9PLUS = new ElfArch(RawElf.EM_ST9PLUS);
        
        /// <summary>
        /// STmicroelectronics ST7 8 bit mc
        /// </summary>
        public static readonly ElfArch ST7 = new ElfArch(RawElf.EM_ST7);
        
        /// <summary>
        /// Motorola MC68HC16 microcontroller
        /// </summary>
        public static readonly ElfArch M68HC16 = new ElfArch(RawElf.EM_68HC16);
        
        /// <summary>
        /// Motorola MC68HC11 microcontroller
        /// </summary>
        public static readonly ElfArch M68HC11 = new ElfArch(RawElf.EM_68HC11);
        
        /// <summary>
        /// Motorola MC68HC08 microcontroller
        /// </summary>
        public static readonly ElfArch M68HC08 = new ElfArch(RawElf.EM_68HC08);
        
        /// <summary>
        /// Motorola MC68HC05 microcontroller
        /// </summary>
        public static readonly ElfArch M68HC05 = new ElfArch(RawElf.EM_68HC05);
        
        /// <summary>
        /// Silicon Graphics SVx
        /// </summary>
        public static readonly ElfArch SVX = new ElfArch(RawElf.EM_SVX);
        
        /// <summary>
        /// STMicroelectronics ST19 8 bit mc
        /// </summary>
        public static readonly ElfArch ST19 = new ElfArch(RawElf.EM_ST19);
        
        /// <summary>
        /// Digital VAX
        /// </summary>
        public static readonly ElfArch VAX = new ElfArch(RawElf.EM_VAX);
        
        /// <summary>
        /// Axis Communications 32-bit embedded processor
        /// </summary>
        public static readonly ElfArch CRIS = new ElfArch(RawElf.EM_CRIS);
        
        /// <summary>
        /// Infineon Technologies 32-bit embedded processor
        /// </summary>
        public static readonly ElfArch JAVELIN = new ElfArch(RawElf.EM_JAVELIN);
        
        /// <summary>
        /// Element 14 64-bit DSP Processor
        /// </summary>
        public static readonly ElfArch FIREPATH = new ElfArch(RawElf.EM_FIREPATH);
        
        /// <summary>
        /// LSI Logic 16-bit DSP Processor
        /// </summary>
        public static readonly ElfArch ZSP = new ElfArch(RawElf.EM_ZSP);
        
        /// <summary>
        /// Donald Knuth's educational 64-bit processor
        /// </summary>
        public static readonly ElfArch MMIX = new ElfArch(RawElf.EM_MMIX);
        
        /// <summary>
        /// Harvard University machine-independent object files
        /// </summary>
        public static readonly ElfArch HUANY = new ElfArch(RawElf.EM_HUANY);
        
        /// <summary>
        /// SiTera Prism
        /// </summary>
        public static readonly ElfArch PRISM = new ElfArch(RawElf.EM_PRISM);
        
        /// <summary>
        /// Atmel AVR 8-bit microcontroller
        /// </summary>
        public static readonly ElfArch AVR = new ElfArch(RawElf.EM_AVR);
        
        /// <summary>
        /// Fujitsu FR30
        /// </summary>
        public static readonly ElfArch FR30 = new ElfArch(RawElf.EM_FR30);
        
        /// <summary>
        /// Mitsubishi D10V
        /// </summary>
        public static readonly ElfArch D10V = new ElfArch(RawElf.EM_D10V);
        
        /// <summary>
        /// Mitsubishi D30V
        /// </summary>
        public static readonly ElfArch D30V = new ElfArch(RawElf.EM_D30V);
        
        /// <summary>
        /// NEC v850
        /// </summary>
        public static readonly ElfArch V850 = new ElfArch(RawElf.EM_V850);
        
        /// <summary>
        /// Mitsubishi M32R
        /// </summary>
        public static readonly ElfArch M32R = new ElfArch(RawElf.EM_M32R);
        
        /// <summary>
        /// Matsushita MN10300
        /// </summary>
        public static readonly ElfArch MN10300 = new ElfArch(RawElf.EM_MN10300);
        
        /// <summary>
        /// Matsushita MN10200
        /// </summary>
        public static readonly ElfArch MN10200 = new ElfArch(RawElf.EM_MN10200);
        
        /// <summary>
        /// picoJava
        /// </summary>
        public static readonly ElfArch PJ = new ElfArch(RawElf.EM_PJ);
        
        /// <summary>
        /// OpenRISC 32-bit embedded processor
        /// </summary>
        public static readonly ElfArch OPENRISC = new ElfArch(RawElf.EM_OPENRISC);
        
        /// <summary>
        /// ARC Cores Tangent-A5
        /// </summary>
        public static readonly ElfArch ARC_A5 = new ElfArch(RawElf.EM_ARC_A5);
        
        /// <summary>
        /// Tensilica Xtensa Architecture
        /// </summary>
        public static readonly ElfArch XTENSA = new ElfArch(RawElf.EM_XTENSA);
        
        /// <summary>
        /// Altera Nios II
        /// </summary>
        public static readonly ElfArch ALTERA_NIOS2 = new ElfArch(RawElf.EM_ALTERA_NIOS2);
        
        /// <summary>
        /// ARM AARCH64
        /// </summary>
        public static readonly ElfArch AARCH64 = new ElfArch(RawElf.EM_AARCH64);
        
        /// <summary>
        /// Tilera TILEPro
        /// </summary>
        public static readonly ElfArch TILEPRO = new ElfArch(RawElf.EM_TILEPRO);
        
        /// <summary>
        /// Xilinx MicroBlaze
        /// </summary>
        public static readonly ElfArch MICROBLAZE = new ElfArch(RawElf.EM_MICROBLAZE);
        
        /// <summary>
        /// Tilera TILE-Gx
        /// </summary>
        public static readonly ElfArch TILEGX = new ElfArch(RawElf.EM_TILEGX);
        
        public static readonly ElfArch ALPHA = new ElfArch(RawElf.EM_ALPHA);
        
        private string ToStringInternal()
        {
            switch (Value)
            {
                case RawElf.EM_NONE: return "No machine";
                case RawElf.EM_M32: return "AT&TWE 32100";
                case RawElf.EM_SPARC: return "SUN SPARC";
                case RawElf.EM_386: return "Intel 80386";
                case RawElf.EM_68K: return "Motorola m68k family";
                case RawElf.EM_88K: return "Motorola m88k family";
                case RawElf.EM_860: return "Intel 80860";
                case RawElf.EM_MIPS: return "MIPS R3000 big-endian";
                case RawElf.EM_S370: return "IBM System/370";
                case RawElf.EM_MIPS_RS3_LE: return "MIPS R3000 little-endian";
                case RawElf.EM_PARISC: return "HPPA";
                case RawElf.EM_VPP500: return "Fujitsu VPP500";
                case RawElf.EM_SPARC32PLUS: return "Sun's \"v8plus\"";
                case RawElf.EM_960: return "Intel 80960";
                case RawElf.EM_PPC: return "PowerPC";
                case RawElf.EM_PPC64: return "PowerPC 64-bit";
                case RawElf.EM_S390: return "IBM S390";
                case RawElf.EM_V800: return "NEC V800 series";
                case RawElf.EM_FR20: return "Fujitsu FR20";
                case RawElf.EM_RH32: return "TRW RH-32";
                case RawElf.EM_RCE: return "Motorola RCE";
                case RawElf.EM_ARM: return "ARM";
                case RawElf.EM_FAKE_ALPHA: return "Digital Alpha";
                case RawElf.EM_SH: return "Hitachi SH";
                case RawElf.EM_SPARCV9: return "SPARC v9 64-bit";
                case RawElf.EM_TRICORE: return "Siemens Tricore";
                case RawElf.EM_ARC: return "Argonaut RISC Core";
                case RawElf.EM_H8_300: return "Hitachi H8/300";
                case RawElf.EM_H8_300H: return "Hitachi H8/300H";
                case RawElf.EM_H8S: return "Hitachi H8S";
                case RawElf.EM_H8_500: return "Hitachi H8/500";
                case RawElf.EM_IA_64: return "Intel Merced";
                case RawElf.EM_MIPS_X: return "Stanford MIPS-X";
                case RawElf.EM_COLDFIRE: return "Motorola Coldfire";
                case RawElf.EM_68HC12: return "Motorola M68HC12";
                case RawElf.EM_MMA: return "Fujitsu MMA Multimedia Accelerator";
                case RawElf.EM_PCP: return "Siemens PCP";
                case RawElf.EM_NCPU: return "Sony nCPU embeeded RISC";
                case RawElf.EM_NDR1: return "Denso NDR1 microprocessor";
                case RawElf.EM_STARCORE: return "Motorola Start*Core processor";
                case RawElf.EM_ME16: return "Toyota ME16 processor";
                case RawElf.EM_ST100: return "STMicroelectronic ST100 processor";
                case RawElf.EM_TINYJ: return "Advanced Logic Corp. Tinyj emb.fam";
                case RawElf.EM_X86_64: return "AMD x86-64 architecture";
                case RawElf.EM_PDSP: return "Sony DSP Processor";
                case RawElf.EM_FX66: return "Siemens FX66 microcontroller";
                case RawElf.EM_ST9PLUS: return "STMicroelectronics ST9+ 8/16 mc";
                case RawElf.EM_ST7: return "STmicroelectronics ST7 8 bit mc";
                case RawElf.EM_68HC16: return "Motorola MC68HC16 microcontroller";
                case RawElf.EM_68HC11: return "Motorola MC68HC11 microcontroller";
                case RawElf.EM_68HC08: return "Motorola MC68HC08 microcontroller";
                case RawElf.EM_68HC05: return "Motorola MC68HC05 microcontroller";
                case RawElf.EM_SVX: return "Silicon Graphics SVx";
                case RawElf.EM_ST19: return "STMicroelectronics ST19 8 bit mc";
                case RawElf.EM_VAX: return "Digital VAX";
                case RawElf.EM_CRIS: return "Axis Communications 32-bit embedded processor";
                case RawElf.EM_JAVELIN: return "Infineon Technologies 32-bit embedded processor";
                case RawElf.EM_FIREPATH: return "Element 14 64-bit DSP Processor";
                case RawElf.EM_ZSP: return "LSI Logic 16-bit DSP Processor";
                case RawElf.EM_MMIX: return "Donald Knuth's educational 64-bit processor";
                case RawElf.EM_HUANY: return "Harvard University machine-independent object files";
                case RawElf.EM_PRISM: return "SiTera Prism";
                case RawElf.EM_AVR: return "Atmel AVR 8-bit microcontroller";
                case RawElf.EM_FR30: return "Fujitsu FR30";
                case RawElf.EM_D10V: return "Mitsubishi D10V";
                case RawElf.EM_D30V: return "Mitsubishi D30V";
                case RawElf.EM_V850: return "NEC v850";
                case RawElf.EM_M32R: return "Mitsubishi M32R";
                case RawElf.EM_MN10300: return "Matsushita MN10300";
                case RawElf.EM_MN10200: return "Matsushita MN10200";
                case RawElf.EM_PJ: return "picoJava";
                case RawElf.EM_OPENRISC: return "OpenRISC 32-bit embedded processor";
                case RawElf.EM_ARC_A5: return "ARC Cores Tangent-A5";
                case RawElf.EM_XTENSA: return "Tensilica Xtensa Architecture";
                case RawElf.EM_ALTERA_NIOS2: return "Altera Nios II";
                case RawElf.EM_AARCH64: return "ARM AARCH64";
                case RawElf.EM_TILEPRO: return "Tilera TILEPro";
                case RawElf.EM_MICROBLAZE: return "Xilinx MicroBlaze";
                case RawElf.EM_TILEGX: return "Tilera TILE-Gx";
                case RawElf.EM_ALPHA: return "EM_ALPHA";
                default: return "Unknown Arch";
            }
        }
    }
}
